diff a/faceit_analytics/views.py b/faceit_analytics/views.py	(rejected hunks)
@@ -1,45 +1,54 @@
 import json
 import time
 from pathlib import Path
 
 from django.conf import settings
 from django.contrib.auth.decorators import login_required
 from django.core.cache import cache
 from django.core.files.storage import default_storage
 from django.http import JsonResponse
 from django.shortcuts import get_object_or_404
 from django.views.decorators.http import require_GET, require_POST
 from requests import HTTPError
 
 from .cache_keys import DEFAULT_TTL_SECONDS, HeatmapKeyParts, heatmap_image_url_key, heatmap_meta_key
 from .constants import ANALYTICS_VERSION
 from .analyzer import build_heatmaps
 from .demo_fetch import get_demo_dem_path
 from .faceit_client import FaceitClient
 from .models import AnalyticsAggregate, HeatmapAggregate, ProcessingJob
-from .services.heatmaps import ensure_heatmap_image, get_or_build_heatmap, normalize_time_slice
+from .services.heatmaps import (
+    ensure_heatmap_image,
+    get_or_build_heatmap,
+    normalize_map_name,
+    normalize_metric,
+    normalize_period,
+    normalize_side,
+    normalize_time_slice,
+    normalize_version,
+)
 from .tasks import task_full_pipeline
 from .utils import to_jsonable
 from users.models import PlayerProfile
 
 
 def _with_cache_buster(url: str | None, version: int | None) -> str | None:
     if not url:
         return url
     version = int(version if version is not None else time.time())
     separator = "&" if "?" in url else "?"
     return f"{url}{separator}v={version}"
 
 
 @require_GET
 def faceit_heatmaps(request):
     """
     GET /api/faceit/heatmaps?nickname=NAME
     Возвращает JSON + ссылки на PNG в MEDIA.
     """
     nickname = request.GET.get("nickname", "").strip()
     if not nickname:
         return JsonResponse({"error": "nickname is required"}, status=400)
 
     client = FaceitClient(api_key=getattr(settings, "FACEIT_API_KEY", None))
 
@@ -238,83 +247,91 @@ def analytics_job_status(request, job_id: int):
         return JsonResponse({"error": "forbidden"}, status=403)
 
     status_map = {
         ProcessingJob.STATUS_STARTED: ProcessingJob.STATUS_RUNNING,
         ProcessingJob.STATUS_PROCESSING: ProcessingJob.STATUS_RUNNING,
         ProcessingJob.STATUS_DONE: ProcessingJob.STATUS_SUCCESS,
     }
     payload = {
         "status": status_map.get(job.status, job.status),
         "progress": job.progress,
     }
     if job.error:
         payload["error"] = job.error
     if job.started_at:
         payload["started_at"] = job.started_at.isoformat()
     if job.finished_at:
         payload["finished_at"] = job.finished_at.isoformat()
     return JsonResponse(payload)
 
 
 def _get_request_profile(request) -> PlayerProfile:
     return get_object_or_404(PlayerProfile, user=request.user)
 
 
 def _heatmap_response(request, profile: PlayerProfile) -> JsonResponse:
-    period = request.GET.get("period", "last_20").strip() or "last_20"
-    map_name = request.GET.get("map", "de_mirage").strip() or "de_mirage"
-    side = request.GET.get("side", AnalyticsAggregate.SIDE_ALL).strip().upper() or AnalyticsAggregate.SIDE_ALL
-    kind = (request.GET.get("kind") or request.GET.get("metric") or HeatmapAggregate.METRIC_KILLS).strip().lower()
-    if kind not in {
-        HeatmapAggregate.METRIC_KILLS,
-        HeatmapAggregate.METRIC_DEATHS,
-        HeatmapAggregate.METRIC_PRESENCE,
-    }:
-        kind = HeatmapAggregate.METRIC_KILLS
-    if side not in {AnalyticsAggregate.SIDE_ALL, AnalyticsAggregate.SIDE_CT, AnalyticsAggregate.SIDE_T}:
-        side = AnalyticsAggregate.SIDE_ALL
-    version = request.GET.get("v", ANALYTICS_VERSION).strip() or ANALYTICS_VERSION
+    period = normalize_period(request.GET.get("period", "last_20"))
+    map_name = normalize_map_name(request.GET.get("map", "de_mirage"))
+    side = normalize_side(request.GET.get("side", AnalyticsAggregate.SIDE_ALL))
+    kind = normalize_metric(request.GET.get("kind") or request.GET.get("metric") or HeatmapAggregate.METRIC_KILLS)
+    version = normalize_version(request.GET.get("v", ANALYTICS_VERSION))
     time_slice = normalize_time_slice(request.GET.get("slice") or request.GET.get("t"))
     try:
         resolution = int(request.GET.get("res", 64))
     except (TypeError, ValueError):
         resolution = 64
     if resolution not in {64, 128, 256}:
         resolution = 64
+    render_options: dict[str, float] = {}
+    for key, target in (
+        ("blur", "blur"),
+        ("gamma", "gamma"),
+        ("alpha", "alpha"),
+        ("clip", "clip_pct"),
+    ):
+        raw = request.GET.get(key)
+        if raw is None or raw == "":
+            continue
+        try:
+            render_options[target] = float(raw)
+        except (TypeError, ValueError):
+            continue
 
     parts = HeatmapKeyParts(
         profile_id=profile.id,
         map_name=map_name,
         metric=kind,
         side=side,
         period=period,
         time_slice=time_slice,
         version=version,
         resolution=resolution,
     )
     cache_key = heatmap_meta_key(parts)
     force_regen = request.GET.get("force") == "1"
+    if render_options:
+        force_regen = True
     if not force_regen:
         try:
             cached = cache.get(cache_key)
         except Exception:
             cached = None
         if cached:
             image_url = cached.get("image_url")
             if image_url:
                 base_url = settings.MEDIA_URL or ""
                 path = image_url.split("?", 1)[0]
                 if base_url and path.startswith(base_url):
                     storage_path = path[len(base_url) :]
                     if not default_storage.exists(storage_path):
                         cached = None
             if cached:
                 return JsonResponse(to_jsonable(cached))
 
     aggregate = HeatmapAggregate.objects.filter(
         profile=profile,
         period=period,
         map_name=map_name,
         metric=kind,
         side=side,
         analytics_version=version,
         resolution=resolution,
@@ -324,64 +341,67 @@ def _heatmap_response(request, profile: PlayerProfile) -> JsonResponse:
     response = {
         "status": "missing",
         "image_url": None,
         "updated_at": None,
         "resolution": resolution,
         "version": None,
         "metric": kind,
         "kind": kind,
         "side": side,
         "map": map_name,
         "period": period,
         "slice": time_slice,
         "res": resolution,
         "meta": {
             "map": map_name,
             "side": side,
             "period": period,
             "slice": time_slice,
             "kind": kind,
             "metric": kind,
             "resolution": resolution,
             "version": version,
         },
     }
 
+    render_options_payload = render_options or None
+
     if force_regen:
         aggregate = get_or_build_heatmap(
             profile_id=profile.id,
             map_name=map_name,
             metric=kind,
             side=side,
             period=period,
             time_slice=time_slice,
             version=version,
             resolution=resolution,
             force_rebuild=True,
+            render_options=render_options_payload,
         )
     elif aggregate:
-        aggregate = ensure_heatmap_image(aggregate, force=False)
+        aggregate = ensure_heatmap_image(aggregate, force=False, **(render_options_payload or {}))
 
     if aggregate and aggregate.image:
         updated_at = aggregate.updated_at.isoformat() if aggregate.updated_at else None
         try:
             file_version = int(Path(aggregate.image.path).stat().st_mtime)
         except Exception:
             file_version = int(time.time())
         image_url = _with_cache_buster(aggregate.image.url, file_version)
         response.update(
             {
                 "status": "ready",
                 "image_url": image_url,
                 "updated_at": updated_at,
                 "version": file_version,
             }
         )
         response = to_jsonable(response)
         try:
             cache.set(cache_key, response, DEFAULT_TTL_SECONDS)
             cache.set(heatmap_image_url_key(parts), image_url, DEFAULT_TTL_SECONDS)
         except Exception:
             pass
         return JsonResponse(response)
 
     job = (
