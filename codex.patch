diff --git a/db.sqlite3 b/db.sqlite3
index 00f73c2f960544026d326672a1aea5766bfabbde..ab0635e836dae3aee52adf10262c32d796407a84 100644
GIT binary patch
delta 58358
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
OE~}Gjbx?yb?Y{x3*k;}U

delta 45625
zcmdSCcYKt^+CH9b$!1e_LkfhFY#JaCSVBvIWJ40F!bZV{N)S*fLI6dMs3ahwSXhcX
z7KBh#tOSr9yFt`rC*ZN766~T!g1z&-uKU?!Ls8HB`|o!?@A8`6d1mgp=k8^mnud3*
zHBB#={T<txevXK+b&7~Ee-RN8F&3W-R`$x{x4oAq+3=^?`6K>~$k|rC+!=QY{wpOl
z4*#Y`_gNj~>bE1q{eyi+pVYIHV<%PjNU)q^nl<%`i4)bNL&Gy7EjbC6u_pO%OZ#py
zt3T{L-(*=mzE3ZcdG+ExV@;_$_Vvm0I4p6KBAiL_g>jQGTS;6}?R1kXqPC>eo)s5o
zk1j1r%_^<lG3nAxW{1W3c7*dI=Mm@II}&PMa_)G0QEm;sd_2PWsq=B?Yxwd(r+(aN
z8s)XLi&(3oe5PA<zY9%QnRawAzZ<tYInvoH&fG5|E}~aNeE+y3(c_}y?46?~MBZns
zwccjg8qv#QHP4B-ko)ETba{n2%524d6|bx-)RE=pVw2uF*)%@ZZjOB{BL1A%#{ls|
zvHG#AOrtG!V#@iu^GASj$f;^p^tMJ?%oa;@^u~IR{GU7MGMhYoF<)%Nm<Z=^rz3t|
z?CH@D+xtb0j=aLQ#{7Zl5By;KZ%NWHd;8j{V@*pIsgh5Irzr22!y{vs^csb4=Z!U8
zo6-7hXLZY=;hk07XT#fdm^*de?3tHeHf{E-iBs|}>^J$M$x|j?K5N<>IRsO#s=36J
ztnN5GJb}}-c`)%L532VL4Zlb&#k8vGD*#)2{>Z5ISBy0+HnlFDt^WLCc!sH$%J_2l
zmCmL8M?|$BJJxi=S(i<^aOPB5Q?36B1G=kSUkzWX>b@ABs>{9}{(?!5_-6Q{rl{Jf
zeWThhJVW`u8J?=1{$zMpweXYSS*D(xFP&dZGI^By)8VVtx=)7N)v`-W@dot8pAJ7=
z_4;i1O#Sdk^JcUC+O*uL_Gg@7QgxpVKh4yQ%cZOM&xc=PtU2%V;XO>IQ}nzs=9?4Z
zN!BLkZ^ZKu=WjT|Bvazzbc-V*F|kv^lF6l}Ni%1bo_ea<I=Aw}lzxQ+`W6lt)O%3B
zzI_Y&_w;xQJ)X>~Rpp|7$*KMF`VYu6KjtzUj~*Fb8XbN#MNc=6m=)U|t9TcunObKL
z4bg|=M?{;_@oS-(07W@Jz`xd4oWD7L1ciU?{M`A0^CJN+W6jc$)`W<3KxeL<P#V4E
z`Z!Z*`zcc=UOH{=q>HB#)XH6Ew?2QH`Bh5}W?56a<tmf$fT{MZ(&)vnUtvD>0lnl2
z^E~Ssi`89wPl6dk6FMcBYI|bnOJmy(EgPp#f7Bdp$-=CoYVWSHV5pNr&%n?ZhqoO%
zPGQa*l|CXqO|5VYiqv=RG|w^PLGzu-_~*+MOmRay{4>V|^uHB@|N1lv|9oN%)|ew*
zI<m_Aw6ha7Gjr0s%O>V|=I2@3M@92UTF&FZY;$sKn*n|A@ta-u)bw@*n#|U`_Obtp
zh~Mbk@0{TbIxC#3;$L=lj{iRXjQGgdf5kl!yCHsI-0Jw;xb|@eV~@mL5?37iqB3na
zuh-to2X2Z~UR9W@+}q9FmFM+nrz#m)8L7LSU8$^RcEc&90zGDvxfSJ8rcS!-l6ht0
zT0u2MwC~Dsz|D!{+73(Uj$vJ#om9<L=Hy9je@V{4FYS+;V8*nWGv~D(mBeM*9|w+%
zItH4=Q@Bimu}tzYKeg+@pAwCq7PUcVo+%=Mn{7`zYqMFI{n&9X!phB>+Ke-h5(d`m
z%;s#zjXHKmi}Jkjf;iIO33Ii9+Z!k7Id0hT8~4V_X_015n5^v%yfK2t#7>Kj8F<1@
zy^e0t(dnszkmC-&?R2Jy=u<EbNCo0r$5lh7PMtNG{Mm+1?3@t<V2oU3uyD)JF!D?h
zQQbLEPWpr?+aSgi5t)O521&FIJRUKo2wPW<Iu^ni(-wiej)l*f#c^_I$Icdp&1=aH
zt!N7G_V^XOW*Nkzh(30rW7hKq8_j07IijxyGj=xpJvY7)MP;0)c1?>;)`?Y>pF17+
zyPtbNZ%;3`wt6dnlrQ@8&whin)q^jhF(QIr3{ri&R3_^V?#hpxL9fN)G7Y8x=%RdA
zTWVFq>LE`3P?K-0JTQ<C^jDKsm8I&mX5WWSJ0=<A_Vo5>tE=*7C&9>93ERyc0^BY7
zWa2|Xd<2#6^GKUov8l+WJWog2)YiNtn|kK!D4X^>Dredr88ONn2NeCEHAlQDSjR0y
zsM;y^_NwWDOq;6y&0^CTjlTWPV0Go)GVk}5Ey_$onT?9$HfBQ@E4}S|*CC6B!28I&
z({J-ci<QGOXyD(2;{uJjR(02+%89zFuJSI~aEU&6ab(bfpNGYAc&Se4?|aaSzkM<M
zd#F0H&0MGJ>e`<t<ID8HZRUVUyXM4R6d&|jt!}+{oB1ZrUmeE>hU<jq;udqlD`mnF
z+SH@-0#0~sOrYNSoc7$%y<SM-*(lxj4$I3n!hb4`#-p~yRc4924qQ>>RQ{3C23i%+
zYEy@AkM61(pD|~u#w#68y}QAZFA$xk06;HQKf5wU4{WwPFJF#PbH0vDR3DD5%+URs
zB40Ep1_UIBJ>n-BG*ZubCw{CTES(#;#la1X)wR!${MJr1US`(K^Q{5v8k;}3-TbQT
zdUIUBWxGw+oi*}ib6~qUSA)_<m{nbUiBmONya7I!Z05HGW@D6gXLp)m=DrpN-L`5|
z>$9Uddty}U-&6S1BPIfIhAutgIy*E0mKhK5o)z%M5#PN{d~}=qUTM~zGdsK*9q`%C
z6DTqCnb_c3YpN+&WjozuK#t*W$x6LtPam3t)wU7lmhoT9S)Z*}E{vLP4y?8M2-B%D
z(q!R(o8-U0w-L5;ND{x2B+Sl0ovnN80@;>()>^H)d7HUOhPy1PVMtC|V29<sV7)CZ
z3`vXyYYYpX+2i@>V1w;T!N^Z0!0nC=HriGYf_d1$fB01o0qp|v<qO>OrD1$I_;;Sb
zG?7&Pq+sPE3m$cwwENy6Gt9dF^Nz}_8)8xiTh~M$3T!tQ<JVhc;J-NV2Cgx}9&|;1
zU<$0Yj>cElns^QmnpMr^mNa}fOE+~*?HnC+N4f~v-KzfD=t0VVTk&A+?q$8Q?OX(C
zs)g1@9wwS06P+suI$42lR`K_qcKr0NJT-(6Ja1B1ZVE9wg=c%cklAJN0bgXW<$SJ*
z3syxwXdn>qULPB*j@;OKdaDFQm*@>|<kn%{iz8ijT^~QjhlzT0o?_+nw{iMu8V5H{
zrr#1DsEf?u$(~{+FK>?v)<-S~osf5T>XWg-hR9j1E4&~pTuM&s!Go`Is-|t`xs)e*
z;zO0yCiUhmmH*WjEUsKHLSUB0ap4TG-IbB8^!*wCe#g3IP-J|Mh<Imgnj_af*xDmv
z(drEMjEXhaPDyYX_HbOO3Fff9v`edwIYzxi<azQ2=6d?(<`ua6!j$h<n3vysP(l8n
z{Qi2cb<ku>Ha5Fv=_ps&yyko-F|U(ULkDZDnz+Q?RryYh@1nO@2Q8;vY!1|J9Oi7X
zi_a-FEq)g8q_)B{PI;Hu)77k6dz7xV54zu!5pi|x#<KX9C&q`K2pjbBgkec*SkgC}
zG9#|3-8do+Ptg8>3vm1zWo;Hw9rNSds?I(rO>c-DG|j{vUSGShBDUr6vrbshcsxg+
z5kF{)kl>PlD|SpPvxcev6FZ4xE{P-7Leeh`i71RMk~91!D(H$jgVeBt?DA_&z}Ieo
zt}7i>6|Y>|&5x?F2L`0X4Dbx<pO+^l0}k|7)8(Y*WX#nvZW-5^Pfph1FCQg&<_3IG
z=O6doji4@@wlxlz>BMxaO#dQ_w{J7uQcicJ-t|TM-{f0UJil0|D+hGGOTL&WUtFap
zEgrZ&PB-NH<_oKR&S47(+>kc2O$;^;nCgt_+dqHcfc`C;SZ!K#(p77YU$yr5RTrPI
zYOpbPsxv;ncfY*+{JcEFuExgvrfaEEQ`>;Dga9tpmF+tIV4~Wv2UiU|DtvVvk#{_z
z1g*<->E#1m4qd&<^0h5KF6ylav+0Hi`%2RdQE%<Ya4$5u*DSZSGpNN}I~5G(pJ#5v
zV4xPbo5Byt>be)qz4i8X)_t~Yu)=MC=82Xk!3xK*Qky4*lOh!;E}iUjX2zPEx+UOA
z8mP4w<H=k5wOtcTEsJU};Xqn}mLWjW#m<;P1M~V0?Avk(D^1H!ilG}%hM}AO5<@q)
z#Sk&<*BdqroEWd5uO256e#|ddQn^h$jueH`Rw>ZmQ*D2NG186CtfsW<)aC$d!5>y-
z^>-iCcKFyu{Ze8J2KF0}=V?9tTM*2`=|gNo2%jhP8XyGsQ_7w$R*IrU7Nh|+Or-E_
zwAdPGU=0=n>vmG;%d}teghuWlH2;wayT=Fo(N%%%=Ea;YO{QC`GY+L3;&km~y1Vq8
z)iK|5I=f7_j_~}+>Hd_z*HbRoMM-=g7ifx3BSrp9a1RN%8;J1EA*E1rxcy>t#74bs
zVN`b*0`skRhNb`e6fKP+i8krJ3!?HYC#VMuIKu>$I8R1x)*If6Pq%5TC+6AHBB$<F
zfNx}At@RJW5EK~h(Q}^b`F<oJTh^*=#F|P8n@|&Z#`o~N?$z6xoac#N#Cg(?gJgSD
zB;C454%k8zUqqY)1PAvK#nr^gO@iY4iDD>z0I(P+b}Zz|abd;Sfs;H)MEi;8nK8k7
z2ee_+>9(a-V?kZ_-KnpW<Rcy?zBhC3vtge*CUCoF$<$+HZ}lX*M>%)7oZmJ*sndY<
zR^6DE?J?=<P6K`tJPs7Vw-fWP%NJKf0g=5-y5Z&oFHUc}d9)yP2SI;_%Vo<}9-$ok
z2(axM(=k5aiRr|xyvgNUvRqJaEAO(#3L2V%XRJapnjmiky`MF*N({Z+&?y6rqr~R<
zQPz4iq*6c!PtbB2tzFlRITRhNj_D`{@<^FNun$0+M|E_;gX&=Uk0n?WlP$;bYiMHa
z-aNu)C2D-8fIp@;Dd!3?1SbelJV~cxAaQM2Do^QzD~BJp>FSG0{n2FbtAh<OV`S0u
z47-lNUoXI45~b?zE4-ikUKebPIa_cK`=}}ALd>@zmLsQ{Njzdi?IQlCTS?5Hgy08q
zR-WwdTLcTw@=PuxF<mdjw3{bz4Nm}8oj3L-LD*Tuk67Ik_{&^z-JU0@uj0%%2pRuN
z;JqpeL-PpLnF7_6Kvir<62kSuao5wPG>p>ogeLy2D&HyohPdlM-om*7d0)tcI0pRp
z=|YDu>PhePS|3GZCF_R5;*ZUIBwa=fvyf6>A{Q7o_5?0+FKvNhf%Ihxffq<M1BGf{
zq0{#msU{U;3={rUp3(cn1FihneKa;ZaEcTm#Menw%>rCM&c25~Ib`-dl!(6))TiXk
zhYL{Y;+Px|95?Ef=cdiJX&9wJ+1bZ3kxPbrD_Z|sZecGE&qX>hJf3|z;UniW(L|<r
zbNjf+hmsw5gU6K3!+3+vlug$854pu~zTmy$si6YO%T`YQCVjSZqlmVT<m(1opeoKv
z1}f*0j|%g=txcB?KMF;CQRyG@*gNDBxOxyKn*|f^p6Gyb`u9%it?qB*UI!cEYAwLI
z4T~Ah_XmWxjdT7Xk=)|FbJ7DuZ5#K#={WcQ;Bn!Bk4OWdXab-A_=K24z#I1lVIVO?
zIo1A&?c>yEdqyX@m|(J+dPmqwqTi0gf50k9GyVTJ3hp<z!-fjDD~qW(BIZcsFjF!1
z<T0hMS>}y`)x&UL?PNsuZ=BuM>KUhDXnktUM!fvGHP=s$Y_Y7SV&pA-+m19Wt5Y=0
zu?uL4nFg*|I^5PW{+ttX2F7@|?)9qq6$_&(pW*X4kG#dc2-L(s%!4s3i!a+)7J<6>
zU%-&Bkl+ow;wv6?8@u9bGDM4A!L$Fb0&#uF=?u%_o8v5t!^c?`&4eUmSp;0pbTZ0+
zMcRHZbpI_EY$snBrp0%ZD#w}@-~W?o@x%XQTKsrY)8Z!u0Na=rfg0yH3WVcBG$%DG
ze)&72B3S2yVYA)bp6Ct42I`$wZnlj{@jJ2GVp0&he-OLZ61#@8EjGoUZEOk-I!YAZ
zAx>LV$kJ)GEKCu^cgV5`x?J1CMuo|&uzJX-2zXr9zp*Jy5MY0AQ<!XoJ#15$A}MuR
zYzlyBLZI)Rls!=zx+O!5lUN3AO!gCP3sW?K{s-G4Sm%0(*qkgvzO88ysK;KgHJlK%
z=3m+uTs)RQ8zG95Ss5G>$0O)L3TR_%nBtGMHB8PEYz;o^;yy<Gv&9i`C9G9ogeNKg
zx6tA<wL4iLXS?~RSQ{ZrB;ZLHOP!zozZ)W^q+<;cQ!+6SGDNs;3XcuZCt&Vm=7_01
z+2fzh5l+>i^<*VRcf3tvO8sY>Bv_Xa#Q^J8;(xO!Tf^8KW(m|M$SI%H7BO{J*jCsU
zF?Bi77BQu@u|)`PI=B8AnNy4rlbfe^qA?P1wfmFc{Dm1}%KRV9kbtM%eT>n~pd}<$
zh$;Iotq@ZV&*(TS#MG70p3DjfRJR)(mKallHSM<39tdD1F+PwiKi2p#^*GM>F!emC
z@nPz9GULOP+s61H8haD1;n=^a4*?CCACDwnfS4>J;gtJt5Z6<p1Fl4C8w(`hPPFNE
z{e2J6T$22Qso${%h^ar>J8XcM2K-M3$md&!B@w_uJ12En?_|vCeEykFnVrJLKBH}B
zDj+u8Jec=m19gc)WIe<(+eZy$D&lGM7diT(u<Bri4Hkz{egQ`f(Y2O#i(<LWJ;F^7
z({?l!>(T{L&xnDoNJRJ0>^33)vdw&ftg%kk@akR5+$DDHT@aNkveHj0(Ns!_JvY2k
z4}Lk6a{C&>e~rLjMh?GT)IklZCYX|_smV!F-n61f?Rm4}6=o1j<plaF)tD0FP<`&s
zx2YOtvivVs*i^&01vY(qL&b%(;!PFgq$#TA$}-GzU71a}yCw%Htkwl|@;+6Q?69f&
z?;Vk<`eCmXQT{Yl-<)aFTenx7Dq9&QoTwmAUgc_$s%oz<SIxdWDN4Vxp~52=98O^F
z(_8!%XULi()CQH9sjAl{Whw8qC27jHJIbN__YFzXH8m9rodJK+>cCp-c;$L0$)SAz
z9x{yp?N;t9Dn0?J+ql}lm3wnylJZ4GW9v5+rmBXXcAIuyR$;K)D4ue@Npegzo3Mwv
z%QGFS`Vg{h?l0~5=jWj|y~tNIU4n1UTdT_la}5WoPRe3*@5vRf(T_8YCgF}S(CFV;
z;!sEL!YWn1iaTW^r>edechdlMkg9tXTd2AwdYGzy)!|T0Hv-*pANd@rab?zg0A0XL
z12(g>*rB|Av%$h=jqGezjg|IP`9(MME2<P=@bEd_QsZQ+BLRB#fTBSJF2LPr_wb7S
z^oLESsmj9^5AzVI%wi&1e_pvw_1T&DGzVve(`(gTx&PBS(|?e^tm<2FryR=|b>wxs
zTUBjI8m5}-6P?OCxX@-GvwEIA6%NsUlk7(OGb?7uX^$mZ?=cY}PF2+-J4w~MlWTY$
zZz=yB*th3Z;3qe+;`P`y$yVx;O$0D4uoY)jeL+eM6;C^p@#k$t*y_fL!K8sy)f|`d
zwyw8SjE)Vsl2f>aF&vy>(ltlQ7Ye|qlh$rh4V~>y)jT3QOZgLuL62R_9#ei-G>~fn
z(wkO0oT@IS0RN1@cAmN3;n0l-%X`WUXK;pqfm?6?=<cd%(@;E@nvE=PYSw|^cC*XG
z)K4CPUC8x4CLRyaG8g!(O2Ukb;*qFy{}$zJ+0^dv7JWCBC8@?&OB~u$p9<_Ti=>;r
zFMGhG8XQTHs{Koa=W=ViWfQvTz4A_CC5_X7>#gwkdaOFa?ojJ@Vb!A-729;<?(&|o
z0blZce7uw^W`XXO62uad@*D+-N848l5%1QGJ203ua;B<$(sEm9Pz!r*0y$pP`iM;*
z-dG+hr+XIV&t<AP6&P&V0EAY(oa8g;wmQa(1r9+-cr%k%D*xW%(F%#N@!S@`bRmm-
z;NKvwl2zqT%3Nm?({CHNbj^1#$JU)3pQPMn-tOE4_?EoiFsmq4)#Y@6_{mNY_}@0h
z)|ahN*xg%X2YEEjkWvkQ04F|67M^+)iTS$A3SZ-NPCRw4!KqD`7vcbK9Eu0-%1_dD
z*OgCTjKOpc<<L3Gvog!6e6x~Lbxn2oLSf`{^_&N7QK0s9NrP0=>)A`W@~7N7j`K6{
zR`b3@(8(nrJpbv1gLV4ka%hkG<YeXQmfT%=f48qOp746J9IE%jiQ|?3{`^!`6$va7
zG3rohp-XK|Dt9Q?7pNovc}-EiTZ)sE>)}KPKp)M;a+R-7QJ!ijgoKi9dj9}+>u-Y0
zfc#1lg2P%#s%d@-=)1ZoO?f^6N*hY;Kk)ff3dQc2O-Q#e#HWi!L+b4rMj1KS?$F+|
z%AXJcavqtv%B1{HMkB16jRSsSM5RNG{oX!NzfoF_z;a{qQkA}=%%%OF@)^!}pzwlT
z?!Ho`(YLRfbHvvn@UY!ykapu~V7_8kVT@kpF278$I+1$sJdpC0Wl4cGb^;~>V7UNh
zC?;K>SUy^4wTj|m&d%!c8|C3i{Iimzi{ZlFl-X+HrJ0ecc}kg8HTDCRn%3bT$h<t=
z=i9PZh4L<>%>LG>-`Mkdxg&V6>^EWl$!hDlB`NBtBOB5+L^=?Mjb(Q_o!HtGmX74}
zAMEYmo`Q6JN<-N`fn}<IrmO4A4A?H>-*h4c&&W7I=7WAKy*7Q?#<GV6jEjj~s28v%
zNZ=F5#tS;)pSn+?M+e4(0uDTsZ`1FuEK83M)TCI+Ez3f}wx(=`tU682>6qd%NV>Ui
zxijztxXe>kkgEJ=Lg6<Rfi}Fo3ZP<6!+f)S6%JKXg+JZnOPql@ju^eGx~x!UnttmF
zdy1;F;m4ZH6xab}Q1r)OvOCEqOI0Ui<to=O=v4o*;v}ehd_UJdu{C&F$n${N;ob+5
zZhWu6rXD(@U?15JlWJ(#^s7Jx>(@gX{o1$Cp%(3e>9Gg0(%41AxB`^v&4+BRIUh{C
z=XM<4#M6P5MTLM0$CwM8cGopi%N9BU^(oWw*C(MB#p-zd^s-z*?o3Lmar|i^0)NL=
z>a2JfARKTOP$2B)wnD;tYhJ-DYGV-1d0@kO2fzT}SsVh>Aja!3ihK^dpXJcN&<vr<
zOL^3dhQ?^P02>|~2bOL;4~n4STj<-G)5^fj7Z!`;TCD0b3dS4gAknMF_!4mVp&`)m
zTa(j-i~|?rE9k7|md(w?4tk>4rD;G}CkKivO|ztiDL-EwxxrDv$!-b@YxTCP02(AE
zJ6$zp6(=g+A&8Lb3o~(G2eY6H8RTve&hHUF7ltUX<ZVbXkwi3MRQg!pVeAxOy=hh%
z)bQ<DPebm3J{nS!q2gwx*z|vM%HqYAoUJybdvjHDRkqJitc}kMO$wZcEKy5LeK7X&
zC0D!HB(vy063hM+YqeS@WLVdWg*?*~{4O6=<(}uGvPcd|+HWnJA*1Fn)tX~g)z5+Q
zh-E$G+o4a(Nzc`g+2ulUIG?is`r%0qu-V@HEa=oh$*EX+5a~8qANXi!XL)8Gxe4O+
zY=`64I&O9{4r+Eo{_n=g;QJ&syTT4~UzY@Wqy(*U+Cwt%n_c;i;J%^1$xN4VCTO~S
zQIXo$F!TZ8rpr}^N`~PD=2A8DLFLtUSQ7s4lE!mFoU+Do)Hh}xfS&D6tUQEGzfL>V
zn-!^^*_8i0g+5p!5tQW0gze$AgR`67fGOCpFW;#e$_mJPr3TZ$?sQTp=Mwozs;(GM
z`Oi+y(+xX^7Rdq4*BdUkbPy!JC*}&++>>PsZW{WV(C`)HmcE4KJNY?@dj|2>Ryee8
z)zAlIs|z%?>J2>(GZh+CHuGIlDQ(rM66T0C3lNa{VP#AOJ9I*Hz~BCS3JX!|P(+c*
zPTJcb%;^qM-z#8U9TFgm%~YE(`*(tP;lU&YPb=>W$8o#)H2M8>N#8)VUxdROa|G5@
z{q+1%wm@C`I?RD29>XXC^g;?*_?-A+oyhpBxYbL-E>wT&{j2FhT}Bt`dLg%K=t5mX
z7w{Uv&m!ITiqbuHU9&poDRIZDnF}%1kn~o`<kRB=t_~7HpX^i?cZZeQ{ajoJ&NxnH
zTtX*vJ7*jvGhR!$o}~Zl6*!k_fQ90Dz&Q|VHManyaVMdKWPEFDX%3fLrfcsQ(n%`S
zR`JQPa<<nSQ5M~pnteM^^jzFc0$~}`KBgPE>@F@_B+D+>rLK<1p;i6Rzs|u#$ywr+
z-pJM8l-0Y%2O2tj%$2)1gN+?N6|6frLxODN7JBzT@b4&@aRqU3l;Hd!fBQAWVYIli
z-^tEaa;J$h_m^@4l0xqiK7mC9bTvnPE^JV$s~U<HTa@oXh-rT|)PR2z^!n@_4wruE
zd2c`2^%_duZ(#2Xmg+L)>I9;%TbcvP{~j7;{T?_%)!V!`p@1s21BRukrZHed?^+6I
z8w~B{#7e6=a9YvbAz|F21@zH6?;iqZfJ?Mj&A<5~mA^d3s+!-A5<_yP0;9YNvC^IV
z2gzOKfTg&~dsSSZI@PK-{Bdf2h>QGY+OM5S@;+!~_(L!hmyld*y{F0|w<(~n0tQ{t
z6b0)c%Mdo64)$e)3*Ily#m3jDM{XYioiwxDrnk)Tj+2LPS9`C|I*sZH`S>?7o%+fu
z?_!Zacc>$)D{_?Y#)>@Eln&I;#M2k~yaD<7P6cci8}j@b_^PULT6CoT((6rh#^Ny6
zhOC?cs&p{~itp9rXjNB}yh--0z|5s|$cNDm0KoL#kha99v{l}3r6!9}eV&Hy`yj8V
z;nrVajzX_&;S^7ixwDk(c}P6>$1om56Z)Ucf>7LQ=Vaq`(_Iy@Ch)+uhPS-+P-di_
zP~hDlRDBnP?)|Fiwjm3Yk7c($GxSt_Ns-TRIp9>4vMO&>$PW23qv$!ElkI(5D0m&u
zbtJJ3sZ(FJnD{f~s)m-!6c;<!2x81`=e=2oc)iNlnA{=o6#57JE~vxi^5k5KzZC%S
za#hu(B2~H0h4=4Yoo@>~l(|(kTmnz%DQeCYQ=tW1!@Q}%y}3g}@fdiP5P+!2pga`&
zqPwcP&<iNehSC&o*S~m3Qs9gn_#vHfd^H^*jy>zVQg;D!!dUrAu@{v8C+Nckk=|>?
zhp8h)U1Hd1W0PR=Ih{o>Y6!`PA)-1?QoaYU3E#cY?#-jY5pZ*Cx~8e*DrdmmQNnP!
zi0iyX&6!6KuWr>=H!1(*lwk^Hbd+AdujG6|%qAkHi>fb8exwDeSpG+M0suSobeKUk
zk5?Qt+`z5lv6tp+;B9Oj0fn~c2cRr{dYMf(JX<nY=G)ApT}%%%O+)ZYxv}YP%Is%^
zNY(wtaM$<LmE;N`-=hvr1r5SkdPKkNFUgTF?^WB9lH2R{H6@?Q-&;86P5P$ll4|+;
zJ~byh1v-1Xxvtgpx>^og9bQ&aDvT$d6mS45IxZP}S5^1}zZWAG7RVax1D*wbc(DR8
zslt+%SU38bp@3cYz)V8O09v#@b)ON9sGkjeUh@(V?z%4fT!U&oLz3_0q_EHE_Ik1@
zv)V;ZfR}%7@=YY=-7wnVQF=>pS`$eJeJ0?)4o?AB!MRD*o*5;tN?`DQwer59-PALm
z!|HaA1I|A?SmxATU&)iQ;|Emjo{CP&_eXw9Ag@Qx-G=dCsNwhX5jV;zw3!VfT|D*K
zWhFO@NPp0fQ7r*1iIPE-&h{=Q^l>yB&JPiG!{^wDYaRC5v=CNoog;f<V3XYuSYHAr
zjfS#*W;O)yR$Bg^HAxP^a?=2K+v3dD!(35KbFsx5YYgb~smxTO1|q(*Jxw?EE9oWh
zJfv}+ev|fRl*|-4_%OxUMjXJjP?)ku&Vp7^L@Qrn6si2`5&Gz<%2OKc)c(YhnX!T9
zj##9=Y+36AV)bP)sBkV1Vi|pD9MRoLc*0yVQ^>TQAY2;SbW;!bSxs*2T+{*1ZH}(G
zGHVmO(%0-s6dHjQ(bxnmH~fbIqjq)kR*0wpgE2H!Ga1<F^DB&=@FYO24tc`<bAU2;
z41+yAAnVfKj<N-RDgIr=;WnPn+`xefr&`n%Kh8evNHa*PCYU^*psd46JEKR_(gM+Z
zT>PrwaXSU!kkId*c-v@_FP?lnTl%F2sjBgao;6<VeL+>fR(7vycmWdHGYd}K*aR%&
zy{*uptNv5GR;20<0<oW%9L=>6u1j?!1vXQ<!_!hVzZE<5iXXBr2x&$M+&2B0?@$w`
z7dmy-?&7rq(<9{7T;<tQkfM6LOL02|)ZE++7@D%DpppcK$>@(E916|27a^r)OOaJj
z>0_h<Ka+UYFM<o_e5^qDe2{8hmb09Mx{iEmgse2I%Lm1n*h%99Ivbb=lB*$^gpr>4
zu~3A8Y)GDlb<A*<p18UAu9!eor@^g{-~fNYW}LM}5{d@-yq+zO{0u6f-@E=nfGfVB
zFE4qper$DdS!|%X(^UlO4-@4OFn=f$j1vc;1N{P?n2uc|Vw^`d39ib_G{T~-Aw=bC
zv@bU36lfU`nu*#&!#STRA)H4wj%7JFO&4q!J^}hd;DDE~ISG_D&PX0a;>6jm^Fmd@
z-vF5cZ?Gr~Zfv*@`VDrA#F18T9hmvpU;xuCMh$csOq)4m=_PPPN`6A%yy=SK&a(bv
zB#X_|98lFgy(<lb)z?BN)-?=;gxCt)cv9d}!hwNTJ{h6Y^&Xtx^b5TRv`s8_E3Z4c
zoe{=4FsWdeaJX)mS=?;K>UsFQ#yR1jJqt1uKdIp>MB2x`3bEbi4M>~WuV;ZqE-H={
z_4v3t@@!@=&J6D~8a!M7EKHoH9?;Z{x4_^;_$3tJK*$l1HU|{1|0>uR?pGl0YX;HU
zfb!IxD~p>%_&lMGbVux@Iyog$clH)HiNJl58tYLec-}P=K`;PEB&UHLU?(7WqMQ2_
z$D;nJ(|ofL0B!nL77QZ!B`(D(=Nwp-`6eeosSYho#O*{dVWW|taj!4&fNB_9lp}Ij
z*Sr&-XfX^yXpB&}<ba3#`f+ipc3+*{fixfvzsD44>hvKDmu-d}=GlQZ8-y>jf@`hO
zphO0D5Nm&v4J9v|8EbR|p2FEs3+eil;!_2W&+uSxHI{_2HaNJ$0wxqi*3`dPAP?eU
zqw@pS04+YK!=r|T_MeU@CWv+ucNiL{8s5u(2w<&NbvJs2@gCx@PlRT<83`CLzU0dq
zD7k(%ENjBY;7JW0^%)O{T7fB<3+Bk~u3ZbuDIXph3XisF$SW<ALZ?v2QqpI`$*)gs
zHn`C3Et#n6uNXGa!tLZS5(ssEUWF6~PKoN<+XEAMm)bTuxfAUk*(!j9<Qvb0ac=LE
zB9U`(A#hc*v;wMpyZMaJvQR4%84f;(u~`~y|Fy*TpVin=JvvqP4KdPYyUDmvA=OU!
z42NfX69OOEON^MYYmWtt6G|u9l<O8K*A-4g1Rl0e!6Bd9g7r7asrRBh@Q_2&L&(Cv
zFeElQ;O+bncM3&41hx}k1C-3})t>@4!|eeRG%dn;L#z%q><<J)IWd_Hp=`9%;y+~a
z)#8Uc)ie39QpPgUNMA_77XqrOtoHm0_I5Kxh#VC-tjPzHf4dnr?vgTrX%^?iCs%v*
zkS9fCNWtS7wDvIFYsg3X7w6k<^+b=C<-<}5rV`loBj{e}X2bQ+RreHZ5RWwxlG>m>
zhkkwYklv!BULe_w!8F1LX94(-^_`~CBq#+>rhn^QY1t(#EP+BWWa;7|hSGnLO1}f-
zIRp1ix52gYd!na^&e4qvhfJ3M$TwmXBq`r&gTjGA4LNGSIje}CU?S5<*GV9wS`Y}{
znhR2SW+ALFOw>zEx|dW&RnoJ%{+nzc3UjHS;A3x(4c2uw$^^H>1?oGm2hr~i2RB}&
z*f~D9@!E00jn|J0ZtOXEaHEj~*b>~Ji@ulGTT8!vveUG$wYDP(V2z6jc)F}+wmQoQ
zaRj_wtW>IPA{=ir#_$&rj<?qj&Iy$U=0`;Lwso|eV#-GuU3XJP?Z#0tD0XABY3=zZ
zbjPrHfIT=GJva}U*dV{6cH?kI%L6SfJK+W#JfQKwt1|YMHA_#8HpZH3Cx$BN!tFgA
z+jpt`FdOg9-PYXbu(yo87-Ls0Y+I#AKv2<lih8qy)uT7wU>_%@+1tUIE~%`(*as{n
zi-q$psptp;CNW}4zNaT;cIsi(U<;{-I4VrApYp(lVxPM9KZ%-oU$3ldKN|{poB3v*
z#s`e-bYg(%pwRY*M0XCc|8{J!xl2EZz`Pc>Chd8wzJMgMTjn{ax8?iBMu7r<mh#k{
zB7Qz%RA($_dq`&cn1_E3XWJw|f5NlRpsz2{nLC`g*TD4YAeH`5SqI&|zUX7odY^HW
zlCl6_E|kU04Mn%eqMuV)+-T&HnqGi3$ZaS~V_+{vc@HCZ`K-T4+Bi*LsBJL?omKVw
z`3~fR9HKB=%;P%^LrP4u6*r~Wg0)4z#-qT|^rf_oX6!FWRI|ImFg=Xyf=;h4+AlyI
zQW@HjqL!CeN>XtiV=cLcj|~mqU9#Zu_YH;4w7~3mrW&RtG$PdOMMWB@gSx-k@+dVA
z{_8>5qU)Je=~G+b)Xf(bIphexQl{*R_Ns9POD!tl_ca}XSvtg5^prEukmjbu>#Dup
zqQ{+q#<b3?AQ)uWEX@fqaQQq%%LUSJ$h{M&Dv`NNgEf!5JeG1qqafa0G+o9VrhWW_
z;jAJ$@tl4#p{Q7J+^qJFalFtb@X+T)ID`I)P!0`~;c>4RjC^L*{bemNh}NPHU1cu1
zL-uh*ZTrKKq?aBkx#jo_yqH)`A3JOkFJF<E6{Fmb+wV}G?@JK)zXmE8K{|LrObXXE
zXMJUume?Qg`a{XP`qS?VlVbwz^d*eiAeDKfd<qSjB<(#|__)CTooa}-y19Ft(=L1H
zwAUj<uRN#1LV<4r|AuLxXMTWE@ef2KtlQqgH{{{(RmM4GJr(i=PBrnC;)z5#>HwH}
z{>zwyZ&%^{^6(Gp$mpD*+FM_U1FA|NV+6nb3Wx2VhMgULC>oX8b%n+${lru1ATbhz
z9j5UhrKW{R^D;J@cW0j6rf01xyh*V7vntL@YOj-P3XO2YFJy*GmFHWSadpd>BG?Jr
z`RE*&*HR$?Q`MpNJcS%aLv^8%p8HiD+#A(iO*{aNhY$r6=_>j;wdLI<F&<#V-*;^>
zv=W1yb^n6GF~W>hg`<RQep9<9M<%P9GfV1>Ocg4EFs3RIig|cB?7ffkQ3P>w;i=+B
zC6U~Z&ueSMa;D3Me%BkW7&aB!@h?)@nyGBT>>ujjg^@o5%D_(5)n&=*05kJ<{|4XN
z)3@+tbXTO?)JNOQ1uFgh!bn~0E;PawM=3`J@c1H;x-7D3WR2w)a|ChMi*{MaLB}~S
zAha+QJP0GOenr7BfZdB6zOFJA-hrr>+selVw()3cmcUt)%!;H^%8HOvd?z09Xa9Vd
zF6+j?R(a-nm@`$gfuW<LK?#RPAuQ4CE{jyYM`0nY*aEPg{I;N&7%@vFZ3miLNJYE1
zA=T@>A8DGFq-CBFH2eKv!JjhRLMGmAq$TfI0WZ3-v7iUf$!sNYWlKar_i8A3UB0xb
zIbZu=#BVoeB6~K8iR3i^-*+jv+W#c@1AZeIVprL$HkBD*!Z{&;>h1%@)Vu+K{QHgq
z$-0>%iQzFc`;u@AK*1f(K()IIeGKtlGx%WJq_slQdX^fy7~WL+K7`j9eo&`w0<DdG
zlb&422+PvntSX3&3)Hy9<VD%b-=(&ntSu19Wsc^iryGG@e@$7f{;s+pN_OrbqQDk(
zpd~el>JiXRRl&>7NMI|*ou@J;WF@vn#3bhg+bf8Cs^R7S1f!qsoA&z(M1q=Q)tr}5
z=}_MhUa!P>fLHNpk+p8gA)f=gdoWDkXVwe>O>M?eN(3UD9j*4!O130}#L5fqpvpAI
zF$gt`nERhI&Keo#(LxdNB+!2wtohGLWQ`>9C^DGYscMT$_Jp&)8rk10L7j_8O;^?T
zp$ZC)H{2M?Pxrbc=T3hJ6A2`OEnF1Zu17X#q{WNECL|gAE0w>w9mmykXUIe!lYt!w
zh8YLvHXH#1GC_~`WyAaF2fy0wfdZ(%87ntMAs*9c1OFd>KarJ55(+?#m=oC%DOZ3m
z_KL3mG=CIhGUh~@Nk!nMeek}HN$Wl&J5M4|=O3HG)kxt={e?N1_^gn$tU_8gPs#~&
zO@02Af}9jSjC&*)??FYNLrs@}L@sI@+^g(_4h|t{cVZ<ZtLu7X{!wFtgzQC#oM4Ma
zV%zXG`1hc2`c@--E4enLj<85!i?`7>?;6-N^a{0S1aR?N7W7N{2Z(?nb1+@7-GK+!
zm)Jfb7pstq#c3YJgY~*1Qq@gI;q3ayylo35aKaF_*Hu6Q#@oOO(?RR5ZZJ%kOb&Es
zpyjk=n~q;S^lYp0mtcGTm%$@){`C(48iv$_WstxZg%0~+2Hd;)X_%?zc~m(eQj?~}
z<|0)+aUF!g(PBuJ*xQDVx6-OYfQEG<^f@W9@})cNS)OPrPqf8-s<|IVj?_BVurh7^
zkz$E%q%r)EYlQKt@61Wn&DRYru?mT5@BIA7qXTsrCr=`~F3(QY4ORJt&Om*}ow{*n
zoCp5yHuFkp57^9nExJg+qHU7FxFH6(KF(h<ryc7rnbX_&OBT$cOMmY0Ocd+x{Z^Xe
z#q{hYA#BdjAiFj`6Rs%%4T#Tlp;MVXnH{w!)D9|XVRJUE_;6a-oO7(x1hWwU{<YJT
zq`q7~D1lq+&IeIO0XzSEG^1uNAXyHe`ydsyXkb8wdp*32{}kK}2l=_Ud6FfrpqFCq
zsW%MIpNQ)s{y5cVrWcna)x!nmKttv>cnY2At@MivG-g`4!8c@?Q{ssX@|kr1qzhy9
zX>|+7<B>!Wj2`asJNgpQLg0M~>K~l)sQjJBJ)&_1p#LDkupbE}K^FNcw8%^L&f$b{
zEnyx&kEI(umN#PrkiMD8b)>jeX7WxU!(CHYmmn>DZ}W^^V(iE~NaIL~WVv0kT)r-C
z&V5*V3#1D*UMOY<op4wtfNgAe>C^aSA#pju%4H6~Lklet;NLw%e*<Yo5A0p0Kz-J3
z!gUXKtYpW7xxv}|Te6FY!2^r`qJMvxG@3fudx-oj09_JZJC$FS5Wy?B?Mnr@ULyB)
zB6qS(T}tF`63=dIXiKn5yL0>Fg$ITb+YbqH$BG~=QvgO2`07ye5FTLj;0j(*aye>`
zP(aG1%UfG0q@ClYNMLw(>-MFNWdN%Q%oRME*Mz<%SX3xDh-**)L#`abFj7sC@u+U>
zKd=(NwY{%oyLpLVU^tKJpgcHP`dtw-dl5k0E3uPnrAP!}(>)N>Ermu;5`Ym3Ncf8D
zeSi)`o)6CB4w)y8?yh+xC!WyKE7c0Yc4;(r2?3d8E2DVSCTS8s)VkF^0O7n)_@?zs
z8!`BkJTzMOJwLsHZ7ZW0Lv6Y01;3xo-rHIu1wuGZB_SC11jUAtKaG&DXXo}XQ=l>X
z6|(Z#oc@n6wJqS^=I}G~n8x{8toI)X)7JvY7~OYfw}%)&zM5a+{vJGaxjcpXElk^m
z0HFXAU%y6x#_BoU$F7KCr}!4Z*YhGEe8g7?sq87CvPwPa!mhYY1H+uMn^H^@Crh4A
z`Z`0NZSB{=>{rU7J>^)X#`=72@;3{fixN~C1Fjd!y;BZp9O-QuNqx1D`goGnJOXip
z0C6U{=4x_LjHH~Ii~lrGo%1XH|4MFD`j@(M<4f9Xe4*9&hTA=xgtC&5To<LGx2}<K
zX!a1I;Q<meQ#te;wn^S4Om8Ma@8%eg5S~3>aC9zvRPGhQnZp6Q@tMV_@MAo`?+DOs
z$eI|Ta@@a!zbgeD6NoXy_*#4P=bD3O_V|@icJp~8kS7G2dxf15*TITIL^z#KHhRA8
z6-U6u0I{AfV2j{h;;v^*usLT7Lr{al&GiXUYr5JrJg-lPzV;#pCsA@7rV#p#t<LS_
zG%uw5`vu>XP#8QffFxVE^+WReWWDl;Ior-J&}@w@-6gm)`qRGS4yI6hqR|mhw_ZJk
zabL>gQ@OoVkrb`Of`JDFFBj<}9R@hjNqwx!I@1EgvS!G9F{v_FmOU$cWNB@|;Igk+
z165riZR$cjlyaQY_$+Vh2ubfdvB$@R%%&se7qdr-qZZ34Js{A`;3;7lXsNs7f(>1#
ziU_?EwOU=pyPOeTpl_h5tCa_E1rK1U%sQJrnzba}g+jd5T>nO5e~w^(4zYi$%z3eh
z<+;TCdQN)2Xx4d#0;j<di>E4O*2{?8ot$-eY|z)O%IJs0pF?EQ`Q(t7WYT`P>Z$8K
zPyqyDOG|dV`fPpoBq&dd+Pl5{sIKWcs4K|pSV`Q$jDxR|)4GDE74GmvR1vGcZVBq-
zt|r|$wW|lFG6n?v-3A)gk@i*&DhJJkXXJnY&+bZYuci02zMBM#9~MaE!VB|N#Ls3S
z_T%sR8Yg<}YNP2Dd%aK)dd;y-vF1f&j%#`T-NJfM@<W%2bgAKHt|YmiB0BdRIptcO
zGW1}zxswEMaA%5K0zx_77|q**UXXE16u|3hP)~5X`92}SK4$2rZ}8`*!Y6Wz2tbfq
zNoaB{5JKM~%P-~rhRKHI_7d}TCu>H=MJ94b3ZP7h!8ypaaOUfYyPI1VkLM=-BlK{C
z!lqg*CAo&hyqr5~CkshGwfRO;nq3H4I<8R}15m<uy<q0>T`+;B?sxGlD@n<6Rg8HB
z5gTs!Hv5UlHXY%Rr&uxEGLB}^@KrSd&neSd=aZXk%xfrv!#CZSkGTpbP}TXkdj#Uu
z=Uclb2J24Az$rD2J`l%ScC^*k{vD@!dv-=PiEAxayqs*YEH;4K2^|*m(FpU=m~T-`
ziN)$DA$;bHHEWiRNJL1V7jf49uU8srTxoPKF9)+MU$d-JG9C|g_?x!enAJ8TFfM$R
zk}fKXSJpuNP;2^{rNfe1p22Nh$K9e7e#W>&N#n}h=h?(>c@NvVi-=uBnQ=Al;5p?d
zaC3n2Xr2g+^*oo=VJQ^7riTcj^*p-sg*-O!WbY$h&Jdp2$dli}2}g>&*hJEJN@%4-
z=G;t5`#0wtAVTQwkQV_y@P<+dKxGcD80>L3>Qcjfo#eYNV(Z<jONV&l5jR+dJZ9rl
z6=DlR<zqmM#Yl}KdLWg+sOdNbG5?DZtvaw6A-w9O?7YCl?9YO0WBe90;33YCj;|YL
zB_g_0h=RgCmt`S#um{09iN~a$hQK1c#v4UDZc!WROM0ogGf~X~zYwnQp<<_0)HQ6(
zY%RZ@r?7$V8EX6ljN36>1CkV6n)93J()-Bkzv(7-cAN=W?zf~!6?GE#6fDFEoDQ}u
z69ei`D*FXS>K8>us9v6n76X=~HZ3ULf}t~7)8nsc)T4}$r+$$Dvi@UX&YvRJ?pKwa
zqmDwwO=Hc<oknIBY3tp5IE~-!GvXFC|7Mk0wEb!3s$ZwOb9bw?0fexY6i?77I!hkV
z=n&~)EQztq=Wdk&Mil{i{Fv2kW~?nqH?_-7kfF_Frw7!*x9yjzrlxYV(Pfn3s`0JK
z6ODa(8UFL{M#yAU=C2aI3VeltWZlS=Z?JF@8O=h_Mz@CA=BesonJ5KFKy@Jcxun}G
zEl^gTsv6%JQrbG~>DCN!qk;Lr4h!M}E`+_gXPQ)ag7F*la-|{wo)u~lvod|a?ncCL
zf@`gaH%LK)e|okg1tikfPHfiyaBmOta5oVVgN(ohQo;w7YjhWsl74Leh8ytEMxGp+
zr*2CknhAhcqa>=i3b8YUS|y>3X+t^Zc?@XBsJi@0574lOu{UgV4}fnR=M50Pt<1o)
zSJlBK+GBPWNT8qx#{aS$@C*L#K>$(gwzETVxFQ6jJM%A>IyxN}S)bi6M>2Hghspkv
zTghb?r_GRkI`sLOIqTvA%{|0WDdsOw*i*gsNRw**9nqJu50zvY$aLR`Dq{C5MW?a$
z_67k;*UTu&7sq0mv5)2t?0F0>O(PzBj4*-g+UMM8U(@q4V%<Q`p2?A?>AH8ao{~qW
zN%b4MNH%f#&Pb9IC7!p@Xn`zBo!G^y`nDpJr{(uV+iQq)#hAl&e~2goC+LD9mkx(C
zsW02ki9(&C&DR!RM`UfIyc(kFv$MwQra42}nIS$x<63K-mMd4TcLc}@xfAwAH}ua+
z($x(`-*U@+S{8=5xY}}vv;#7=B36Z>7NhNusS#c0DEYT+thLx;4IgO2{s)UM8aOp)
z5UZI}aa1_^UG@cpZ##A6Q#`&+9KIjJLp9TA$w58!d=yVGc*=sE!!mys#*&tWZb2p?
zyj&Y5DP1)__D}MdZkcj0NeBfHETV0BU>BF)p=w|5xfj`n?4BadAJGZz2G*J=V@Z<|
z#gsdxzUO=__o!*vRd=RMC8{4_)x<%K@uQ3+p})L173egEl8HiF!ib5Ci^_~~W{rZe
zPGU#yB&l9Sf2$Yr8HPiI-L}+gAhD6PRMs`Vy1BeNir-MdQ$L|%8Q0w`+>yq<<P{wE
zDR49hABr3|R|MwK=ER{F5X9R#=nyf1T^L0nBZ!V5d4D^nW%bhc!YoKDg_=7LaVspC
z`?Y0+h4vjP=i+U$*H1~6H%11ldp6@y7SMRcpvWI#><}t|G1jd7AV?6|OpwN6r=ij#
z8HcDpSV33cmVIMXpr+@S*aWJ{SV74WLV~`RRXEciVVeb8Mo9=Af%`Zv3HPaGe<j}H
zW6G3@+%_OsC`P%$a^NpR3rqqigK0GW3BuZJ>_gDJS9mjA`wmG8fKW_?3U_#~gc)5w
zn1z-3^2A&G3;hZdgYI?7lSt@;c>rKemoVo#!aXKX*HaQ&OE?tbg1)eC^(o5;#it?y
zpgitE)wAa<yODVm#T6QfbrH9pYX@IIHfj`T?G-TC(6wChuV8!Wnh*~g)i{fiP{K-{
zZq7g;8;Q+O{UQ>AO92`(-vB{CLo@oKB-{na?6NyKT1@gMR6;N7K}^2DDB1CjfNn#M
z(4mpjm;Q3|lcd~R8RiD{IZ@2#{;Dtyv;+Kr<z(jl%rb_{gBW}_1bZEuI`!-2*|}ni
zJw;<~5a|Eq5>W{D5RulG<?65UvRz`3Jxz19piTZuTJyx%*;<smf|{|DGuYe{c@jxO
zd&eU^zA!ljN%xs3tMDacKM=pB*Aim_ADciQKDUS^S1U=}D9<17y_-aG)VLp@q!jsO
zDI37;1jqzDz<*x1OQF^njT2n~46@D<_Xf@o+h~{C6>Ys)s9(2MG|%Iyf$mUds%yT@
zS}0q2mis*yj4~H!liXZOhrt<~c_}c#f@^79^v$Y>S9M=y!d3u@;pB$Mb3)2la-jep
zL8=v%SV_A6i>%RNYVM}@GtrQYXo3T6y~K3Q$Mzas<&WMD*xTXu1*v((<p9!3fomC%
z9MwpUE`+Dh>l6-LLq+3-LVO)r4_*<V5AVu~6?^!3>X+w8MOo@$s^72cvz(|I=!KgG
zT8p@m-$Fv;b5;?D3W#$JV+pl!(m!;+LSr7{mbW2^TQvjO8`q=Ad0?xU1*K)W{>`l4
zMEJAqTWXb&ed!YoizL*HnigDZor~Q|vGWq7V0cNoMp^0u_CR&7(;z{<(8zzkA~3(G
z=8P;#R=xI=!7h6j9#GR4na<YAXw-y<0GC4XZ*V93lB_4hJ9vrcJU?6>j%xS}n4FDY
zMgplgOQYoo<@%lC0(HHF(SIXq&_jDA*y{fC@DJ!Uk80bgpPH0qWP4vxeSflF5u(3i
z%e4>GVt)VI;9c}WAeit8>~!B!K<mAx&=Hu4{C>@QS*T(NT{(g_fv<6YhR`o?fhvam
zEC$@djP%dos>ZcOm(5I43rgVY-b|wg16Yllk@9kXgRHWUJStmJzW5OQjzhap*n+fL
zht`!MwfoGh{n4m*GQZkSU9-BVi#qz5JqzVLSx>Ox-Tay~g!7*PYSIiZYLK4Cxz0w0
zT=(>3HHxBrU1dBIe}G^ht1bee<}=5OECfn2>I__8f;T;t#Wt2m+LSZD1YIRrAWG_~
zJsMJH4ve6LtQ+Ik;PQT)3uMM-X@-VGg%HzAO<D8hxc5?IY}3eOkCvtP5#5<gcOwNH
zl8vANRPyNgO_@t&%o}`WqtSYXn*zj`y%-^#RSt+uY12ZPkJx-kD3^-Scl{^x0uf^W
zAt+*CU1-vWH#kNcyF=L)ONL>a&juGXoQq0qT(L4xzqdOxLw58gcZA3gN+pJg=)!57
zgX<6c_QFJZ7f`aif}vr%qoeXwBh@}@5*wL@p#+17Rn90}Q{di_xnE{`i&A;6LCDez
zRa2KKw>IE<3GnN`3|76ypLw<H_8rx9z~R>EHJR_r-|uozI*|jngsr~rqxc6k1k#*S
z!&5_lF1r}CcV4E!8}HF{*cti>oSQ0TWHnC@MJ8em`t(+qV?I+~oL`xxZnMNBx0b;=
zP{t~a^gzu6s9%bllKF!maz7EWtBp!j{t;{gNQn7NgTAvR5Qzp&NckS3>fa~OpHu6g
zTAj7Lel$I+x>{7Fcrs#8T2r5!VHkk&z8kM6^9k9klnI_8(-oMdw^5_Fak>C;fbM_W
z^k@?oIX*plkTHNzuWZoWTP}LKCN|*d&G!y?7)-cK1pX)7QrleUr^Hz(7iu<t)|x3a
z3P?%lpX+coG*~yZJ;RyzF}mfATZGb1{txfavJAq|L->4!&)4|;7oTtNIgC#;K1cBR
z7N76%`5vDi@WGqT%s=6SSE8AJ!RJ?e@R}&|@A&+I&!6}l#oSoJV#3Fa4<n-h%L3lF
zEJD4B1@APHU<_V7f>%mKSkQ}aLBFI0*FRby3M{xJ!h$y-;Y~^rmUj3g;**3AUXo<N
zJCZDTVU(o<KB@S0#0T$YvvkI%3qEQ1;FVDpH$EBoWa7gpQ#L-RKOJW2ivQ?_Pj`Iq
zvNlT(e0t*33!hwkdgIdvA5^DX@FFrx9zOl>>5tC<d<Nn(=p>iQH7tyJ(&FF^mZq4)
z5iy6!OdEmovKR!bMy9j`t8g>D1gpa3v2BA@as__h!Eyg4eyj_D%&+vpog;cjY2T;)
zUS~zC88=5h7xy%SPsPHu|0R9ANP6in^zw}cdF+$mQxB13hbfibXYk1_q}$94%*VV=
zmf6W9A=x7&#&0>PLni%JXS|hiAexDP<Bq}KC0zTRhMbC&nCFkO*!NuAC5wG6i~T_2
z>==%oEhfl6l195Se)g8E_7g$$a5ZV5!UfnzK62g?O%AP>Q1#Oi!udsmZ6MtcntN0x
z|CM5LOnCA!ocuRE$I@;^EFU&52wNx4(eI4-?g?KI77)|s4_%qiZfiUfZl}qxKMBeL
zS>sw+<0!GUIJ`zjtYL{D%5LEXW^n@+69c2SaRXC`E{mCvZsZx9OSD)l#M6T^tB<o<
zBw`TctiyN)7QBV#P|CBMuuvw9WJK{*PUw*dqX^bpoUp4*Xs1YNk_kJ@gi`Buh!eJx
z2_2z`V&li7zJ;oNE^eA+(9GPVCFWiv7`WK)vKTIFe74u&I1SGyj>l?=<0&S|v3?=T
z#dG;IS?)twPU5{t0k-6RF5_b^ikbeL_eGgEfj|~>6Hm(~+7T-wWZFk$+C+VDzWX9%
zqMnOumKgp$j4)b~$SUWBC-?HpWIgANkvLWW`GJWF!Y^A%A)@ATjpedNdqR2@5mh5g
zbRZ1Z3FM;3VVna9e|U0vsw1(rmXKEo<eiv-xrei!DZh8-`PFk)X(F+7A%Y&4S%(Tf
z(iE0`j<ZU=wFR{;yx9Br&}|Q9G%ar8={?S#DYK)x<&KO#D5V?SrP`_+nw%pA8A&1}
zGl?{qk0APZSt^S}|1+1e%1LMIy;YrIl;hn5Obl9bC=cSfmv3Y*a-U%buJ(zn){Pj-
zlv8+5P$VTTxFQ@YG|CF65JdySD7uK#N}<b8PW!k_+mk3dmDASCw7rO;GiBO)WZGQf
zs7j_?%W4xO!?u~*Wb^VktJJm3=d9PstWwib!&$GAS^M(%mJ{)FWm2hWStFBPBCz%&
zHr5f=3j`be^_+%YD`1GB6qpN0Im;uQa73&C(NfMLm)=X2DWo?r@}f-IKb~n1zFgon
z%0tcz%ig!BpG$r2j7{W>1-x#xdnoq>MOuWI`>2j`=V}D<hAsEGhcjFKg-{3c9AA({
z1`6bb+*+uQBj{`YzNA?aT9+xNyc$iww+SXnh|ckX-+KiWUP3)lCcH}~ELE6rTKL%d
z5!#{pV7tWhI127_g>9CYf}Z{xSwwLVb6*YbtiSc7l~=Qc{7`d(&M{eKnyex<CU<d_
ziGuLqlw9}m1kaEY96^TMLAXZ>+)@(q6i;wQO!&eejaPfUYzox%&!(KdS0HOI!7&}b
zJL+qBa<rb~an!+#y$f}so>yQ3;<^_YuMYTg5@?aD(NMIGu-?8XgO*PvIXpt257FfN
zvW?3VV93Yl_$eujw)|#ss$U-~2_TNxPgSjhNxAjxa#W!|lGI-U^ZV&Qp-(p6hBeu)
zfGU{oZ5%WhimAqRWV0V<(fARBdHZZc!SL4K@aIuFN_7j%@B_`p^$Xw$Nk0JY&9Lcb
zK8q@%k!it8wH_OKCXLJm3=l9j1|#^-=BVG}Y2u7=qZbaBVey~5LF$`t939k;cM=v}
zU?z@M^Nvi%PM`gLIfAj|*PZZbaSaZy!>Vq_h6}tgO*Lzn_fOT^^NcqZF-zRh@K#!G
zN`Q~sdV$~a0V#Zc6C#{URwz#nx>J3(;BJJf2|4f_Cc%l6TX%dpFt%Ov7Y=O4w*E}A
z|IVO=#i!C27bYv;Cz0?Z5&&w=82q#1Ryc+@KDgr(N^E+d+y0zDT}hGITS1avXE?1W
zZN%v&vpBL{_PGoR-irV`JcQ6KQ7AzFf<C!M(?ZjAD1G&x50t0(L;lO1oKlK-H$0=N
zQz~$QQl33dc;s}hftI)F_GEpL*S<y;K10nZ$mxg3Dq6_kC$lqb96W$Zdyn{lcYyfY
zABd}c>sSQPL7q~!kKLS)jmSlw>C17?S12DN@#!5v{zM}JQa>A&oT&I`4r_$rlUC0`
zmP{IQ_f+7TH!mA<8;2IW$hi^Ixf~>kRs}fMlaue~pAb72+0PY98Bcn?U-@#ewe_cA
z{if%DQmIQvpEkUyM!Q4~Uj@2+8Zn?NW#4B~)>b2yx1W@ZV2n7Z<;n91P?|<9uE8#6
zar)5!esD{y8cC>7Te(g7=6Q1wghTHtfFdd2(xA}J`s=4R*`=}1ayF^2Bj#9X^iFyT
z;7xk>A-n^^8zLA#M`zThBG4>%ELBYa&JnnOPsGW&`kKYbF<{Jb*rC+*qq`QY7jKgg
zZ4<-e(w_<fM9ACNNqsSzEE@4TI0NNqv<^jr5TX67?Zq-%Kri+Ez=`QM;VKXJoA&pF
zP$%#L&(6AIlU=%sE$0zko3Vvyq=-m$MQqkV9u6328PW|BU&WuL$d#g_o0nj=J>?vu
zaj}kfa8zH37@@pcuz6QvOOV-IGL0PWQ1Q3tgG^6Px|?1ls3g?2iPUQ-aQ!w`KoDq^
zJs0F@)73xQm(xtOoX>N@jW_JOnH_XIM&P;=xM4;F4EvUr(hv%9pW6ar3OM^1)zwwK
z%8f#8g+gtB_d!&E5z16`cq+QW8^>frs5nu(?6XAQFOv5H;-dqjiOIUBD|(L{;zWL#
zDS>|GT_g*NxIeMsi!0m8SUSqxlL6t1dk|!*84zs?bOtui3??MH-{{W*Sa7O6h#(yk
zz*Pv~b_{$6Nq_ejQNk4HIhcze7X+>ZF~B3Oy(OO6Wr(q|TeRV}5{RNXV4j*@*^HwD
zwUk{=m0qlZ{sg1g`l%$T+m%>w6D1z<)Z?>kl0^3Xf{-Py-N9jxKuQ}0+e^W^Jz6u3
zn5R`j;)+vg>_vzvlzGHb=t*luEW(Yf(XYB2SeY0otRq%%`<o4?Emy<Txe*_#?isz@
zx@MqAnlp`5J$e&>H{PE&b{rD$&6n~fJWsTAR#+wx^KJ&EuK=SYWG%oYAjmU7G$S7V
zsnLUsh&tlofg8|};2(pUZx9I5^Kv-9*arbIP-3_~m|adbb@TgRww4<Lo>mQJgiQWb
z9$hO6TyAl^l6c1}evgTJE5yCCRO2fkDO`Xd*9!sE{n$PV+-<6)5R4WMBl#+$@5eiD
z29}6OGp-cF4Fo_Z4-R$e&@1e?pWOj;ifj4s9Yfe)KyXG)ba#z=-R40j^R}v=8_UqF
zy&m<bXog0!{Dsk@M9xi7d-J0+HLjL;PiS;1`Q%Qc#bDH0Btrca0G3^k8dLT_L>XAe
zkP8`)zC#|ln17>to_9S7z8YRcV3d2&#T%lZ6d`qqaT!meHL0W8IvqTN@HB3)U0C7>
zv_lN84w+getIs9vK`mt>;OQzTj#RFvqB{iF;ub!^rha03bcujHO_k0<D6H|3q33EG
zR2TUjy5$_q!|Q1DgS(=oT+1?@Hr=&GKE>Y=mqGjb12EMXJz0RC!Jpm6vRluCHbesx
z;+-kR?IdWK<_(Ry?xW~)W!;%HIdRu91loAj^fc>1K4s_S)nFD$k)wC+Wf>_iBfNkE
zeadx4Qrga!9UfV6mfF_cj)pTfO8KXPX#X~%+}s}e&Of9;q-l3HFF;r**d)AfOZk35
zK)>Dxu;qG+oRLT~0UaP^x#GwJE^WDs7xH8zHjXySA0>j%)a@|k9-dUHs@P)UJq@(i
zl!HF1`p*y`MrXVs>1X3yGLvD0Aw|@|?f8iOwU+9E>R_LwL^Poxt0Px$vzt?AcpUG_
z9_NtXZlRBPOjKE}mk#%Rx}&k0Hxbk+TD^WC+c>h&95<xQA=SK=xwOz>R)S@ZNWY!B
za|Hx}$mFKkUZ?h*?zmsjE%zp(MeLZ+^I4M|n}qx>qZPB9{5zP}Zetl*3z9{WOLurh
zsj7YgEhx`4IwJKca~yl+xy#kw+r9m8Sq|<{98}}jEt``!1YR9#3S$#%U7sQ(YKjYL
zpr7+9b}9G%f=Io8l_MRM4Fgvb3q}k&M&^{u3Nt0bY$))5DO0ZZEaPtPmLPFo+#$5f
zF<l<GlE9xYp<;zl@f!U@qr)bUEL5pAs95<b8^TD!`kp4o%ks-rs_$WY28vH$=*cy+
zHW)q5%V10!)*f#RX)zR;O_#uWD3+`cOU6CZ7a@@S+INmz(Pvka$G31R7<6J(StF`E
zL(btEo>;^2;bP5pTiMJa+B$y|9bS`vvf!|#mV9^e;IL&ee`^yQwk+Wq#|4Ki*R}}`
z(;!$%?>l^vqUE|1?-~eJ=cfp-)X=jx4&!<rMoXyJf=diT-fC;8*izIcR2-<!FQa^#
zB<|mNxWF)f0vYrSdVlhg8_UgYUvkrw|1kXF6#9OKX}CgTE1`<TH3eOC!}qTJC}#`3
zLAk3~xGTwQ;j%}|D*BV*H|SYb)1M5zK`-Dfu=0e$MU|FYi9Wly#Zq-?32@Dpy39az
zfji_7OVy_3HX`?g63>7i^PX4`YPsWNwWF3h3BoYJiIkXH)}FK!)p8e+-L<ux^sj4K
zE$dEN3~O1>t+W))u7N?_4oMe=?b}q=S~d`We_fAj+1RFjH{dD!hUk|_mX!BeHghw7
zQx9ypn+R@GL2S8)C=68?lN9f5i8P+%m3fveq|=j?G8d+RR9;|MK;D#RxnE-&A8~V!
zvr1kHqb(2ob*RPiU@P%XIX=|#5NX)Vki@TI(LBs8#7g|LFx*GPxXpa)H&KD+LU|QM
zibR@^dvU8pE+liy&=cRa8*ml%4#!*O2HZvGFqV0c93ZdCv+UsOYc@ayznL~cT#rZe
zhIdEd%{5@j?ILn^5;*vu_(EP#gR<{`c+;>&6XVmlKY2H?<xwIz{0=<JV;bTv{OTFY
z<HT+2i;wGz<n;jm@U~>jlYA&vIx^%k{r}4=nS+f*A266R8Yg+J#C9H(`&ek8&obWk
zOv-thThC?{;4OmSFz!b%vtfCL^#2d9o#wa(iuV_In#Y&4%j>HxyExB{+{!$x6@Krv
z<yj&MMdc`)3B4ej)5#4%p9wXzd6hPQd5+A|EU^B~+qeV1!GDq}a4~+>VCz4>^*d0F
zQ8>}?oAWHV5$7Z4ESO2SuaI?U$Wvl>^6EUxO9Wb8S`&H?IU#$Qr`1~^JMO*Z^@9gf
z@wvl|9PA)`))8zNTpe!H7|r>Qe-qaura<Fhxkv!z&!K*f|Jxhc3EJyC<u-5Nv+OzP
zOK>cWCwmEwW$&>s!LjUPbUXYK9LpQrc<3cKLGKVK(l*u7*eKqD;~UcUEjR?}Eo!X?
z$w2ZN9Lw93zd>^CFtHcjA;E-SgJXI3e|QZ}qWbS_BNelsR8kkxnOyFD1q|FDR+=BQ
zQJVbyLoVMCR+|U7e2dyFz7<E~KC4ZVBwLas2NgCR(whNyv6Q5@QJWthqc)3EDE7am
zxRv+LT0Z5Wv{jp*am}#WEIw9kexdN|32KwDe|a*!dFZ5i6Pe3n_2$<n*PH)U823Nv
zO{6yYCfTt3f59AVF1{2rfW}wUb%dHtEXZ)4*pp&8LJa<m=0wi3^%b++>UTux9XuvO
zb$-wN{GICjfk<wvI)5Y@+o;Z;{!VrNd~(%ENPgjd!VN=~U&#c=E6?BlMtS~za^)Fl
zEXidT$-CU7p*#QN9{y5y5}2c;oRca~E7GJbZ-G0R^7OV<o|wvNCUb{gG#l`Et!<TO
z!0XMS6gnlWJFPYX*G6|*BmYTvTBF+N&OnWK4y=$U?)LiFfS(JtRh(7_@!Fy|31AFK
z^B**)HI`5Pf7F~@Bu@9O>7LE@u)o%w)_89HuXU%@$y50U-MOap<&!JTpsRGniR#kY
zj_5gFU0M^l-IJ+HYZ4jcAJrwdoUE{$Uk#<nzf=BMYjRloW7Vd$!(XdStK5>%R&56T
zUGq+&Fgb50zH1gLt3~M<8k4_t=4NO94|=oow$`WrZz?m;R4Pq-Z8WAe{X~t4T&Bbi
zFAdwD9s-zgtiH5n9;+{{S=>PQowe3%o>9v?YXiQan>pWk&S2G0_^Z{9c76m?q>uvk
z!5C(*t;ip@RhD>b2q-PAEUl;f56UtF6Pa)4gDn|R*$;?dAJ>;EdR$!yqiDTx6$Cgm
zowmHSH>Kj|<k)0fF+5Z__6YS_OdO{mh5jz8*F=Zi+Lzn2;k<a=TfkigbFB5Yw}7W?
zkFFZrxz3^+%DXIO0ZcCW;ec$jKN&1^?;B?tpb!3dYI=0&76%M_iTP3MK(1IIEAD2N
z+p03klgh(~a!#P8>^cP$qFl4(Z7EEC?hqyQ;c<!2-QuvzEox5_@3E4TY%*fRlJ!6Z
zHi9AxadC<y`1&kH{O-UG<VKq=MRj!ePJO;BOS@l;dRS&eP*U#7Wmz`gL!)bMO1Vnl
zFHnF#)kv%Kc{VdjRbNzKRj>SkOHms=TxxFCuc|t}(h<N7>}th%2qCYy7^Sr%2V}X_
zlTV@c_3#En`?sbco;SOgIZwWVrq6yxY3HQKUHsNU1)3YxCOgDi<^m|GQ?qU~UfMEE
zElNgk6R*2NKn}I1+<SkM)S|Nlo=G5f43shuDydv4ZLk(`;(^8`SA%^i4GbP35rQvo
zz_WiMC&t!=1V&#GP9K^g*G*c7D9~M%uJWX;l?UWLh%eQ|H2VzYX$K6oBzKUs8!wGs
z{V@}A4WXAqA-Kz%K@n%dZu$N#-le92)~o2ySxc0u6E2&tI}I^9=f5#s-R;a;;#xJl
znglr!UKLX_99KNyPB)wjt8y289qCY4UTS|)0=<D52v*`IXt|Ha>g9GSBp<nRY|2AU
z)W%s$-5yC0E1wNv<O4Pw0CFA6u~!sdPpG)H<xU!uT;g>sP$Wp<u?n1MjRwhmpZuUO
z(@@S`3&hS-{{NOVBj=QAv;!J_bsPUO3p(n1<a!wS#btu62~gI*A7mgMjSjp-)jvN!
z3F*Uul0G~k#p(Vs`F&xuGG+SQ{-vs_LhU!+t|IRakObG&DD20r_OtCSR&#7VHVKOP
z=Gt#p@ND?P2<G|OVPM>%%3V8yOl0HSP~0AR-Q6R`43ZZ>N&u;gszkgluC+x1&odQz
zH9mOn5?)28UHg;2wg$ZA$;O6oW%MB3u*#0x!f-R+``Y(x@`G~Z6{M(tF~21NZ1g$Y
zk65MmRopf0$!B_+cP&-FowPj2mTrRg>v6pyi0Ph~Vl56PKg}2!BHgCZT_#F`TTiP?
zUM*xh{Qq@!t<h0cSJ))yhD-)bU}n$|l|i)93OKQ_5LB25DTEL*ER8OCn6U=6D;l8|
ztXK-gqIQXoRG6y;B(#->r8Q8TTY*B9(&`cwr9KKML4krSFjbcoAEn>--I>f}Ai?$r
ztd*Jj*k_-8_IKv&y}!+uo=Xk91&K@DK-ref2*e=9Q|c!CgGz82l7=sh%LG#4*T%;J
zlle=>jIm2<!0IQmsMaXDnk7Z$PxXej$mcwjC)kDceve%<7NPfKdqf2>F*dgpW~eI!
zLTGR^F6Wg>6;YO!s1F*D8Nfw^fdtwo(p*<-`>1W>{ej7Ou}4Qubfpn<{M^Ak^PR@&
zfyr|6W2uSd3e%~`^+X?(*g&6HXKZ$r40<lM5wq^%Jbq)KR<~8q`d2fS#)XPL9h)No
zRI)aYn$b2*urk&kp#o!{9XvR!r?cj&Ktxks$sNmNDISAI1UJDc?#D-Oi0II1Dhas$
zZ#?B|a?r4GoMx_y?H@<t!g{Vs@HO96R_cb`<x}pch4G-$6HJXP%LI!R{v3dL4WqSX
zyhq?G2@tW@?#VmXZi(WH6_uWycH@(nm+(M@a(29kKs_RK>X9~|2QgqXXK_MsFmMBL
zx!E*9tkOi<I{e%!A1Az45iqCN3hd)ym6>3#4bYV_z7;ASTC@@s6rkOHuzNj;b@5pi
zGd6}G?#Ol4@+*WPqBWEP)vItOxBxv&+<+{)GJ!q)6F(XQ1j_<+L}e7LR=$}%i$o5N
z@ZTL^^hfv;$u0;2p?<Y5qkD*ZB3y}H4L5?ecv(#t)r|Z7+d+<7rl0mVy0Wu_lZeVA
z=Xo#`w=Dn`<7%wK-XkF@-U?Noi4rgxkekfXIL8yEe*xw8s0ju3vBSBLxEfl70ZV~T
zP|j-7O6J?g{qTDV??-k9(qDlHv9seXe}9lbmwgL<ILH7o(38yz@K*FDKvPL4`mhH%
zNOBHyNp?6aFhRw(a7FztoX=yLb$l6M?stfNft^#m%@Vl{(S0neB2#K)*_F6Aisv_#
z<zZQ{rY()O8kJRcv>ve1Qa&Qr{`xV`({A=ba6axmHp_FKgF7D0vZK>3+h{k{p{frN
zB7|UaU}uk<$T<h%S2E~_H2H;iJSatxTc9#Z7S_z!fd8ibVz>h86JsmFXq}iy+_BVv
zlaa*f9LpvJ8nKySi_~XGrP=a;r=A63DDJ!!JBQ)R!nyW{rJnLwr0hy(Xp>(NDswHj
zB%m076$^OrA_S+dX!N_#ejWE@@8Gd)^tz=Q3Rq_6sVo_-5IOru3>ZS&LM@;+JR%m{
zaUA%2qCX&;?G>DJ7W!L+eo9<<*A0t<^3}3u^&oBCEdOj8C6dbevpSi32W1u6H_U|1
zR7?Zdq8kKz0>b$jFM1;+il^st(4eD((F51-L2UHsBRzf0xtiLRE>IAkS_Tuqrp6!p
z0_e7Wcz&TB8r&C?S_~$CmAEDKcNj)r4PjW<?KB?lTLNJY4pSeCM4r<}3;f-*i@V-N
zAF?{;hqPxLZ01KU*C%6-GPYdjlj(ksJm5q+vG-i)kxq+Va4TEy#EuhLILU@6S_cp(
z88Sxh0Sc<I=#RN&iqR5((V|v3q7NNv=VC<bqP0+HFycp-j|CUVwD%`0|HLYC1{_0y
zvQ&$uUrLo>!J)V<zJ$$%Sa}n#^M7Sf7+@wL3C?b~9P!$=2RnH19(d|9<4jmFv`L6s
z&->}b)DUhq9+WImM~@lo>7v+n?R^O$+l$Ae>n?1>^)O6Dfg}_17IOCXV^==fzlW#K
zW(tjMQX=<B^(*kJTAE1cn1ljkY!e)GNm>KW2)Low+4Wgj1fdub)V6rAD8Ye>T#)Su
z3?s6O9{_Brgm$1TCGl_94Aj`Ak6(VV-TGN1*C{FVzg)l(NBaju;@^C>r~hC<tnho!
zxLibVslqjID2jgb_eo=rZ&b$Nf6m0Z65;YQ{oq4e${8u081Op#Kk=O{#Q(knFuFm<
z@kqh(!c-MV7QcMcX72bIaYb*3TzkVRnD~hGBav{n5jfiBLY>z4eO(1YH}PSmTIc;>
z4yYmgxo4mqT8fn$oC;m<T7j{n({EphzEAyJ9W+F6@2w>&-p$;+iSF`1rLJ1^!d)e5
zH?QWLfM_4n15%1F0@bd9nUAG9@MJ3FUZ;83a9lU-wh=WDgS__#-82&vx4y}TEJXtz
z*2E##k5`cL%}ljRUpODul4zy0)j=!ft^(+r?X}Z#4)H$3E#NHgbe&PlUMM$M0F*$#
zms&UL0u-%q!zIiDNszTB_6%segC7d)F-Rs{b|yGTtIJC~6~JF3h-5n#?jDdqG6M+5
zJJ2Ph+Gh1MsWq^F4FW_3u5$<Ft%G+Sl6r>vLIPr5!%SiHNO)nFioyZ#^t~M@77Hs0
ztRXxFFJs~SR~-H={N=hTtuYb%0wKMPew4pT$Pw-YAM@>z+1$#jSxmn1GGt4kjME9t
z^KF+A{D8Lqsrwrh{Z)pzKXj3FV%bk0>VlmOQ){3_mBAym77di!Xyrou!JU<Z2~$gu
zT<5Bpz75**BJ*W2kdS$EPDRwWRufZaXN??HqP!tAVe*N)*xcqc3?4FrHBC#h>^YZ=
z%60biK*X58)ZHHMe_<K2xt%8=VIKN#lKZcBAof_EB&^d2@8D6vH9B2Xi$gPw4j?Tu
zZ>G~?Ga~cmhdiZ7mTiSbC(E|Nqw640AD&F8Y|G5x>wc+&0>$FZOdIb@#^TLgZ6~sA
zv3LU>sB{ubb2kM_WQ=n}v$*<_2Phf64d1TmaUrky3GYerSMr0|9K>oKP>8_N{M0>V
z$z%f)fu)(#5rHM2B&MgAIKuDB4t~ZF?$ijsE$23mBYc;y>Rk{IjX6NJz&u{>^Txts
zEN5Lyfl7=-Uuou3(iDBAxsRhuqpvjg(*%?Bl@#Cs8eTD;7xcn_>UrRHRyOJ0u3#05
z5oyx`nqR*}w}(jlJ6DTjO~i#|I{n+38*dylSOpi=WL})-p4&Nv#Z|ZD#G1x5Kxmxd
z!xv<y4g~MSOScFm7Leo;r{6j%#HGJw2>V%C@I%ye2FIm&nChNHD_kxse1sRl3K(8X
z4_$FxEMo4b5f4;~)Y3Fi&38-o^AlAFv31$iykU-s1<Sz#kgUoniigTa<Up!xD3ypU
z%|e>FpDS)YJ`=g6Q4+;(I5XF4CY3`0E=vqrlzXKK`Pv8_y&AjCjhe&Pm1%W8&a=no
zc#f8jN9|yhbt(S!<0zis>U)K&?UJtX#`4_?XfDZ#FEKZ3D1Gx{P31>$>lciK7t4N@
z*suuEP5y`%KFmQB=!eNtM$lBU#?@j;lTT8!S=8*8`dir(UcPY_DZcJv6^3b~4Fy!D
ziL9pNr1|*d0~*tEYPYwBo)I$L?TH1)4#0)iir4HRz*5l#t?|&<Cvs>kt;Wr<XDQjI
z*?1wMtI*$8y;fNkBV=SpWh)Q?^R-bE4DzQW>Ejd`?h0D|)l$omTvtdaW&!Vbim^Yl
zl8T>_nrG68npM<(iq_Gr=0!M8O$2VKDDgWQrCNN>9~!iPIcRq>b_|}a7$Z$3eX?OY
zB{|t<4QHYOSJ!Ex!JQ+{#_-mnL$F$;e``47I7@L2dy<B&{&64UMLbi9;mcoZP#;h|
z2D@OAiGXBjH?8r<_zZa#P?^{pL81gD^u`yP@x|Zu#TwpsIr9aIIbr3RFePZXOpfpK
z{cf&CFFvvXe_p3Idil+zl4&iS#y0A*mt4UiK1$?{W*v>=WzA2n2GpYUh2T4+x+p6i
zs@SV3JV4IWQatfXZNArYMIGSk8B8)q6dmH>K7FO+4skzT+70*Y<~+qYFj7BOcf-|x
zkWdck9>WxJn?_ofjjOlfPj}$R0ZL9Iekg#zn$P(Ytprs|_-1rAL!bvlwb@(JiU!gs
z5yYi|T%R%|Y;+RcuLklt8%|9JIglD$8E>jUG9Ru_%q_%zMb2##EdtD!GtD*$ccm0|
zQOY4jDCicx;Ln7yk%mfyJ4YtWa#kNr<h_ng0L8|!F*QV9IVjtK<Gv?9-dX`NP`HGr
z<e8c|MQ%RYV)=;YIh}Q>rBK2*zQD+BiX;+jx`^DSNFt5$I8r2$W*ebrk&sIyk>;<Q
zqZCP``I`%pJSXT16-@BP=Z?FUaCQ@|XSDVY%FEb7GZ0CnQA$R~B$3_iBURnHC+dTb
zp5Z<E$3DRiyupR@E6ze`u&DFUmM5b$c;rd7!M!f)_M&Qow`1I|a2)Ai|0>6k2KKLY
z2KGBT1N+yh_%yJ8gMKmz_OVdqK28B(K3utrfFqA8nribVr$0qgZQi1gX*mBj?KmCh
z-{Gs$asD5i<BoBDmyPSc0nXDh#0OB)0ouo#EAJy&)pIn!lh8i4qY{O39fAFO)O04;
z@67;v)%|x0_WL;YG_Zf4YVHv1L*v_leR%vJf^Q8>@OE!3GQJ-sLf!mQNPm#ZPeb~D
zQu(Jx`a@K48qy!`1nECaLwc(G2#4^t+(SFOk2jBRp|-6Q;2*Ui-6;Y8*eL-2qYS`r
z<ybNS|6f#SXMq1P#p?+0LscgOez<BVHyI1*>ysECi&V{nvY*!|Pe%C9G7<jY6ty#i
z|C|cXMEK(w2(R+@Qz87998(&?$D6Ajlo!7>;h$Y{a7avW|C(BN!9CVeg)GxSktN1C
z9k#13{{O>v>kKZI(_=g0w$Q>i$97As`KQEoOBMK?V0$=n61K-8kv-0%_jb7|A2XeX
z>Q*inQF~Okx^PJCQQgY>-%;K2&@wtjbt|7*ISr~?-p)`R%hKw~UCV$|VY{V{E8hs)
ztus%9?N$Mes{?GO7=;{flKz<=bm!>O5Z>xx!<aJ=-tx6ac+1}&;jI8imqK`}C#Nh8
q;jObcUnzvQ&dx-5%2LE+g9HsU|L#TEQV?$ybDebt@gFWL?fzf=y+%3!

diff --git a/faceit_analytics/analyzer.py b/faceit_analytics/analyzer.py
index 5a5d548e59167c0df104e3916c896e1a744e7ebc..896eb366bc95d26063eea68e98a85f29e3c006ae 100644
--- a/faceit_analytics/analyzer.py
+++ b/faceit_analytics/analyzer.py
@@ -204,50 +204,77 @@ def _to_points_xy(df: pd.DataFrame, xcol: str, ycol: str) -> np.ndarray:
 
 
 def _world_to_pixel(points_xy: np.ndarray, map_meta: dict, radar_size: tuple[int, int]) -> np.ndarray:
     w, h = radar_size
     pos_x = float(map_meta["pos_x"])
     pos_y = float(map_meta["pos_y"])
     scale = float(map_meta["scale"])
 
     xs = points_xy[:, 0]
     ys = points_xy[:, 1]
     px = (xs - pos_x) / scale
     py = (pos_y - ys) / scale
 
     # apply user offsets
     px = px + float(OFFSET_X_PX)
     py = py + float(OFFSET_Y_PX)
 
     m = (px >= 0) & (px < w) & (py >= 0) & (py < h)
     return np.stack([px[m], py[m]], axis=1).astype(np.float32)
 
 
 def world_to_pixel(points_xy: np.ndarray, map_meta: dict, radar_size: tuple[int, int]) -> np.ndarray:
     return _world_to_pixel(points_xy, map_meta, radar_size)
 
 
+def _world_to_pixel_with_time(
+    points_xyt: np.ndarray,
+    map_meta: dict,
+    radar_size: tuple[int, int],
+) -> np.ndarray:
+    if points_xyt.size == 0:
+        return _empty_points_time()
+    w, h = radar_size
+    pos_x = float(map_meta["pos_x"])
+    pos_y = float(map_meta["pos_y"])
+    scale = float(map_meta["scale"])
+
+    xs = points_xyt[:, 0]
+    ys = points_xyt[:, 1]
+    ts = points_xyt[:, 2]
+    px = (xs - pos_x) / scale
+    py = (pos_y - ys) / scale
+
+    px = px + float(OFFSET_X_PX)
+    py = py + float(OFFSET_Y_PX)
+
+    m = (px >= 0) & (px < w) & (py >= 0) & (py < h)
+    if not m.any():
+        return _empty_points_time()
+    return np.stack([px[m], py[m], ts[m]], axis=1).astype(np.float32)
+
+
 def _downsample_by_tick(df: pd.DataFrame, tick_col: str) -> pd.DataFrame:
     if TIME_STEP_TICKS <= 1:
         return df
     t = pd.to_numeric(df[tick_col], errors="coerce")
     bucket = (t // TIME_STEP_TICKS).astype("Int64")
     return df.loc[~bucket.duplicated(keep="first")]
 
 
 def _normalize_side_value(v) -> str | None:
     if v is None or (isinstance(v, float) and math.isnan(v)):
         return None
     if isinstance(v, (int, np.integer)):
         return "CT" if int(v) == 3 else ("T" if int(v) == 2 else None)
     s = str(v).strip().lower()
     if s in ("ct", "counterterrorist", "counter-terrorist", "counter_terrorist", "3"):
         return "CT"
     if s in ("t", "terrorist", "2"):
         return "T"
     return None
 
 
 # ----------------------------
 # Auto-offset (outline mask fitting)
 # ----------------------------
 def _auto_offset_shift(pts: np.ndarray, mask_L: Image.Image) -> tuple[int, int, float]:
@@ -396,125 +423,253 @@ def _save_composited(radar: Image.Image, heat: Image.Image, out_path: Path) -> N
 
 
 def _make_placeholder_png(out_path: Path, size: tuple[int, int]) -> None:
     _ensure_dir(out_path.parent)
     placeholder = Image.new("RGBA", size, (0, 0, 0, 0))
     placeholder.save(out_path, optimize=True, compress_level=9)
 
     small = placeholder.resize(SMALL_PREVIEW_SIZE, Image.Resampling.LANCZOS)
     small_path = _small_preview_path(out_path)
     small.save(small_path, optimize=True, compress_level=9)
 
 
 def _demo_cache_hash(dem_path: Path, radar_name: str, radar_size: tuple[int, int]) -> str:
     h = hashlib.sha1()
     h.update(dem_path.read_bytes())
     h.update(ANALYZER_VERSION.encode("utf-8"))
     h.update(radar_name.encode("utf-8"))
     h.update(f"{radar_size[0]}x{radar_size[1]}".encode("utf-8"))
     return h.hexdigest()
 
 
 def _empty_points() -> np.ndarray:
     return np.empty((0, 2), dtype=np.float32)
 
 
+def _empty_points_time() -> np.ndarray:
+    return np.empty((0, 3), dtype=np.float32)
+
+
 def _extract_points_from_demo(
     dem_path: Path,
     steamid64: str,
     map_meta: dict,
     radar_size: tuple[int, int],
     map_mask_L: Image.Image,
     dem: Demo | None = None,
 ) -> tuple[dict, dict]:
     if dem is None:
         dem = Demo(str(dem_path), verbose=False)
         dem.parse()
 
+    from faceit_analytics.services import demo_events
+
+    rounds_df = dem.rounds.to_pandas() if getattr(dem, "rounds", None) is not None else None
+    round_start_ticks, round_start_times, _round_winners, _rounds = demo_events._build_round_meta(rounds_df)
+    tick_rate = demo_events._tick_rate_from_demo(dem)
+
     ticks_df = dem.ticks.to_pandas()
     sid_col = _pick_existing(ticks_df, ["steamid", "steamID", "player_steamid", "playerSteamID"])
     xcol = _pick_existing(ticks_df, ["X", "x", "player_X", "player_x"])
     ycol = _pick_existing(ticks_df, ["Y", "y", "player_Y", "player_y"])
     tick_col = _pick_existing(ticks_df, ["tick", "ticks", "tick_num"])
+    round_col = demo_events._pick_column(ticks_df, ["round", "round_num", "round_number"])
 
     ticks_my = _filter_by_steamid_numeric(ticks_df, sid_col, steamid64)
     low = {c.lower(): c for c in ticks_my.columns}
     if "health" in low:
         hc = low["health"]
         alive = ticks_my[pd.to_numeric(ticks_my[hc], errors="coerce").fillna(0) > 0]
         if len(alive) > 0:
             ticks_my = alive
 
     ticks_my = _downsample_by_tick(ticks_my, tick_col)
+    t_round_values = []
+    valid_rows = []
+    for _, row in ticks_my.iterrows():
+        round_number = demo_events._safe_int(row.get(round_col)) if round_col else None
+        t_round = demo_events._round_time_seconds(row, round_number, round_start_ticks, round_start_times, tick_rate)
+        if t_round is None:
+            continue
+        t_round_values.append(float(t_round))
+        valid_rows.append(row)
+    if valid_rows:
+        ticks_my = pd.DataFrame(valid_rows)
+        ticks_my["__t_round"] = t_round_values
+    else:
+        ticks_my = ticks_my.iloc[0:0]
+        ticks_my["__t_round"] = []
+
     pts_px = _world_to_pixel(_to_points_xy(ticks_my, xcol, ycol), map_meta, radar_size)
+    pts_pxt = _empty_points_time()
+    if not ticks_my.empty and xcol and ycol and "__t_round" in ticks_my:
+        pts_pxt = _world_to_pixel_with_time(
+            np.column_stack(
+                [
+                    pd.to_numeric(ticks_my[xcol], errors="coerce").to_numpy(),
+                    pd.to_numeric(ticks_my[ycol], errors="coerce").to_numpy(),
+                    pd.to_numeric(ticks_my["__t_round"], errors="coerce").to_numpy(),
+                ]
+            ).astype(np.float32, copy=False),
+            map_meta,
+            radar_size,
+        )
 
     auto_dx = 0
     auto_dy = 0
     auto_score = 0.0
     if AUTO_OFFSET and pts_px.shape[0] > 200:
         auto_dx, auto_dy, auto_score = _auto_offset_shift(pts_px, map_mask_L)
         pts_px = _apply_shift(pts_px, auto_dx, auto_dy, radar_size)
+        pts_pxt[:, :2] = _apply_shift(pts_pxt[:, :2], auto_dx, auto_dy, radar_size)
 
     ct_pts = _empty_points()
     t_pts = _empty_points()
+    ct_pxt = _empty_points_time()
+    t_pxt = _empty_points_time()
     if "side" in low:
         side_col = low["side"]
         side_norm = ticks_my[side_col].map(_normalize_side_value)
 
         ct_df = ticks_my[side_norm == "CT"]
         t_df = ticks_my[side_norm == "T"]
 
         ct_pts = _world_to_pixel(_to_points_xy(ct_df, xcol, ycol), map_meta, radar_size)
         t_pts = _world_to_pixel(_to_points_xy(t_df, xcol, ycol), map_meta, radar_size)
+        ct_pxt = _world_to_pixel_with_time(
+            np.column_stack(
+                [
+                    pd.to_numeric(ct_df[xcol], errors="coerce").to_numpy(),
+                    pd.to_numeric(ct_df[ycol], errors="coerce").to_numpy(),
+                    pd.to_numeric(ct_df["__t_round"], errors="coerce").to_numpy(),
+                ]
+            ).astype(np.float32, copy=False),
+            map_meta,
+            radar_size,
+        )
+        t_pxt = _world_to_pixel_with_time(
+            np.column_stack(
+                [
+                    pd.to_numeric(t_df[xcol], errors="coerce").to_numpy(),
+                    pd.to_numeric(t_df[ycol], errors="coerce").to_numpy(),
+                    pd.to_numeric(t_df["__t_round"], errors="coerce").to_numpy(),
+                ]
+            ).astype(np.float32, copy=False),
+            map_meta,
+            radar_size,
+        )
 
         if AUTO_OFFSET and (auto_dx or auto_dy):
             ct_pts = _apply_shift(ct_pts, auto_dx, auto_dy, radar_size)
             t_pts = _apply_shift(t_pts, auto_dx, auto_dy, radar_size)
+            ct_pxt[:, :2] = _apply_shift(ct_pxt[:, :2], auto_dx, auto_dy, radar_size)
+            t_pxt[:, :2] = _apply_shift(t_pxt[:, :2], auto_dx, auto_dy, radar_size)
 
     kills_df = dem.kills.to_pandas()
     attacker_col = _pick_existing(kills_df, ["attacker_steamid", "killer_steamid", "attackerSteamID", "killerSteamID"])
     kx = _pick_existing(kills_df, ["attacker_X", "attacker_x"])
     ky = _pick_existing(kills_df, ["attacker_Y", "attacker_y"])
+    round_kill_col = demo_events._pick_column(kills_df, ["round", "round_num", "round_number"])
+    tick_kill_col = demo_events._pick_column(kills_df, ["tick", "tick_num", "ticks"])
     kills_my = _filter_by_steamid_numeric(kills_df, attacker_col, steamid64)
     kill_pts = _world_to_pixel(_to_points_xy(kills_my, kx, ky), map_meta, radar_size)
+    kills_pxt = _empty_points_time()
+    if not kills_my.empty and kx and ky:
+        kill_t_round = []
+        kill_rows = []
+        for _, row in kills_my.iterrows():
+            round_number = demo_events._safe_int(row.get(round_kill_col)) if round_kill_col else None
+            t_round = demo_events._round_time_seconds(row, round_number, round_start_ticks, round_start_times, tick_rate)
+            if t_round is None:
+                continue
+            kill_rows.append(row)
+            kill_t_round.append(float(t_round))
+        if kill_rows:
+            kill_df = pd.DataFrame(kill_rows)
+            kill_df["__t_round"] = kill_t_round
+            kills_pxt = _world_to_pixel_with_time(
+                np.column_stack(
+                    [
+                        pd.to_numeric(kill_df[kx], errors="coerce").to_numpy(),
+                        pd.to_numeric(kill_df[ky], errors="coerce").to_numpy(),
+                        pd.to_numeric(kill_df["__t_round"], errors="coerce").to_numpy(),
+                    ]
+                ).astype(np.float32, copy=False),
+                map_meta,
+                radar_size,
+            )
     if AUTO_OFFSET and (auto_dx or auto_dy):
         kill_pts = _apply_shift(kill_pts, auto_dx, auto_dy, radar_size)
+        if kills_pxt.size:
+            kills_pxt[:, :2] = _apply_shift(kills_pxt[:, :2], auto_dx, auto_dy, radar_size)
 
     victim_col = _pick_existing(kills_df, ["victim_steamid", "victimSteamID"])
     dx = _pick_existing(kills_df, ["victim_X", "victim_x"])
     dy = _pick_existing(kills_df, ["victim_Y", "victim_y"])
     deaths_my = _filter_by_steamid_numeric(kills_df, victim_col, steamid64)
     death_pts = _world_to_pixel(_to_points_xy(deaths_my, dx, dy), map_meta, radar_size)
+    deaths_pxt = _empty_points_time()
+    if not deaths_my.empty and dx and dy:
+        death_t_round = []
+        death_rows = []
+        for _, row in deaths_my.iterrows():
+            round_number = demo_events._safe_int(row.get(round_kill_col)) if round_kill_col else None
+            t_round = demo_events._round_time_seconds(row, round_number, round_start_ticks, round_start_times, tick_rate)
+            if t_round is None:
+                continue
+            death_rows.append(row)
+            death_t_round.append(float(t_round))
+        if death_rows:
+            death_df = pd.DataFrame(death_rows)
+            death_df["__t_round"] = death_t_round
+            deaths_pxt = _world_to_pixel_with_time(
+                np.column_stack(
+                    [
+                        pd.to_numeric(death_df[dx], errors="coerce").to_numpy(),
+                        pd.to_numeric(death_df[dy], errors="coerce").to_numpy(),
+                        pd.to_numeric(death_df["__t_round"], errors="coerce").to_numpy(),
+                    ]
+                ).astype(np.float32, copy=False),
+                map_meta,
+                radar_size,
+            )
     if AUTO_OFFSET and (auto_dx or auto_dy):
         death_pts = _apply_shift(death_pts, auto_dx, auto_dy, radar_size)
+        if deaths_pxt.size:
+            deaths_pxt[:, :2] = _apply_shift(deaths_pxt[:, :2], auto_dx, auto_dy, radar_size)
 
     points = {
         "presence_all_px": pts_px,
         "presence_ct_px": ct_pts,
         "presence_t_px": t_pts,
+        "presence_all_pxt": pts_pxt,
+        "presence_ct_pxt": ct_pxt,
+        "presence_t_pxt": t_pxt,
         "kills_px": kill_pts,
         "deaths_px": death_pts,
+        "kills_pxt": kills_pxt,
+        "deaths_pxt": deaths_pxt,
     }
     debug = {
         "auto_offset_px": [int(auto_dx), int(auto_dy)],
         "auto_offset_score": float(auto_score),
     }
     return points, debug
 
 
 def _limit_points(points: np.ndarray, max_points: int, seed: int = 7) -> np.ndarray:
     if points.shape[0] <= max_points:
         return points
     rng = np.random.RandomState(seed)
     idx = rng.choice(points.shape[0], max_points, replace=False)
     return points[idx]
 
 
 # ----------------------------
 # Public API
 # ----------------------------
 def build_heatmaps(dem_path: Path, out_dir: Path, steamid64: str) -> dict:
     out_dir = Path(out_dir)
     _ensure_dir(out_dir)
 
     dem = Demo(str(dem_path), verbose=False)
     dem.parse()
@@ -666,62 +821,72 @@ def build_heatmaps_aggregate(
                 },
                 "cached": True,
                 "analyzer_version": ANALYZER_VERSION,
             }
 
     presence_all = []
     presence_ct = []
     presence_t = []
     kills = []
     deaths = []
     cache_hits = 0
 
     cache_root = cache_dir / str(steamid64) / map_name
     _ensure_dir(cache_root)
 
     for dem_path in demo_paths:
         demo_hash = _demo_cache_hash(dem_path, radar_name, (w, h))
         cache_path = cache_root / f"{demo_hash}.npz"
         if cache_path.exists():
             cache_hits += 1
             with np.load(cache_path) as cached:
                 demo_points = {
                     "presence_all_px": cached.get("presence_all_px", _empty_points()),
                     "presence_ct_px": cached.get("presence_ct_px", _empty_points()),
                     "presence_t_px": cached.get("presence_t_px", _empty_points()),
+                    "presence_all_pxt": cached.get("presence_all_pxt", _empty_points_time()),
+                    "presence_ct_pxt": cached.get("presence_ct_pxt", _empty_points_time()),
+                    "presence_t_pxt": cached.get("presence_t_pxt", _empty_points_time()),
                     "kills_px": cached.get("kills_px", _empty_points()),
                     "deaths_px": cached.get("deaths_px", _empty_points()),
+                    "kills_pxt": cached.get("kills_pxt", _empty_points_time()),
+                    "deaths_pxt": cached.get("deaths_pxt", _empty_points_time()),
                 }
         else:
             demo_points, _ = _extract_points_from_demo(dem_path, steamid64, meta, (w, h), map_mask_L)
             np.savez_compressed(
                 cache_path,
                 presence_all_px=demo_points["presence_all_px"],
                 presence_ct_px=demo_points["presence_ct_px"],
                 presence_t_px=demo_points["presence_t_px"],
+                presence_all_pxt=demo_points["presence_all_pxt"],
+                presence_ct_pxt=demo_points["presence_ct_pxt"],
+                presence_t_pxt=demo_points["presence_t_pxt"],
                 kills_px=demo_points["kills_px"],
                 deaths_px=demo_points["deaths_px"],
+                kills_pxt=demo_points["kills_pxt"],
+                deaths_pxt=demo_points["deaths_pxt"],
             )
 
         presence_all.append(_limit_points(demo_points["presence_all_px"], 15000))
         presence_ct.append(_limit_points(demo_points["presence_ct_px"], 15000))
         presence_t.append(_limit_points(demo_points["presence_t_px"], 15000))
         kills.append(demo_points["kills_px"])
         deaths.append(demo_points["deaths_px"])
 
     def _concat(parts: list[np.ndarray]) -> np.ndarray:
         if not parts:
             return _empty_points()
         non_empty = [p for p in parts if p.size]
         if not non_empty:
             return _empty_points()
         return np.concatenate(non_empty, axis=0).astype(np.float32)
 
     presence_all_pts = _concat(presence_all)
     presence_ct_pts = _concat(presence_ct)
     presence_t_pts = _concat(presence_t)
     kills_pts = _concat(kills)
     deaths_pts = _concat(deaths)
 
     out_dir.mkdir(parents=True, exist_ok=True)
 
     heat_all = _density_to_heat_rgba_pixel(
diff --git a/faceit_analytics/maps/zones.json b/faceit_analytics/maps/zones.json
new file mode 100644
index 0000000000000000000000000000000000000000..c4b45b7eceee2c2c97874b5d00baaa52f2e476b1
--- /dev/null
+++ b/faceit_analytics/maps/zones.json
@@ -0,0 +1,64 @@
+{
+  "de_mirage": {
+    "place_map": {
+      "A": [
+        "a site",
+        "a ramp",
+        "palace",
+        "a palace",
+        "a apps",
+        "a apartments",
+        "tetris",
+        "ticket",
+        "jungle",
+        "connector",
+        "stairs",
+        "default",
+        "triple",
+        "firebox"
+      ],
+      "B": [
+        "b site",
+        "b apps",
+        "b apartments",
+        "b short",
+        "market",
+        "kitchen",
+        "bench",
+        "van",
+        "back hall",
+        "car"
+      ],
+      "MID": [
+        "mid",
+        "top mid",
+        "lower mid",
+        "window",
+        "catwalk",
+        "underpass",
+        "sniper",
+        "mid boxes"
+      ],
+      "ENTRY": [
+        "a ramp",
+        "palace",
+        "a apps",
+        "a apartments",
+        "b apps",
+        "b apartments",
+        "market",
+        "b short",
+        "underpass",
+        "top mid",
+        "connector",
+        "catwalk"
+      ]
+    },
+    "bbox": {
+      "A": [[0.62, 0.05, 0.95, 0.42]],
+      "B": [[0.05, 0.55, 0.4, 0.95]],
+      "MID": [[0.35, 0.3, 0.65, 0.6]],
+      "ENTRY": [[0.45, 0.15, 0.7, 0.35], [0.2, 0.5, 0.45, 0.75]]
+    }
+  }
+}
diff --git a/faceit_analytics/migrations/0008_normalize_heatmap_values.py b/faceit_analytics/migrations/0008_normalize_heatmap_values.py
new file mode 100644
index 0000000000000000000000000000000000000000..995f86c77e0b0c5895d6b4b9ba577eeb9a0584fa
--- /dev/null
+++ b/faceit_analytics/migrations/0008_normalize_heatmap_values.py
@@ -0,0 +1,47 @@
+from django.db import migrations, models
+
+
+def normalize_values(apps, schema_editor):
+    AnalyticsAggregate = apps.get_model("faceit_analytics", "AnalyticsAggregate")
+    HeatmapAggregate = apps.get_model("faceit_analytics", "HeatmapAggregate")
+
+    for model in (AnalyticsAggregate, HeatmapAggregate):
+        model.objects.filter(side__iexact="all").update(side="all")
+        model.objects.filter(side__iexact="ct").update(side="ct")
+        model.objects.filter(side__iexact="t").update(side="t")
+
+    HeatmapAggregate.objects.filter(metric__iexact="kills").update(metric="kills")
+    HeatmapAggregate.objects.filter(metric__iexact="deaths").update(metric="deaths")
+    HeatmapAggregate.objects.filter(metric__iexact="presence").update(metric="presence")
+
+
+def noop_reverse(apps, schema_editor):
+    pass
+
+
+class Migration(migrations.Migration):
+    dependencies = [
+        ("faceit_analytics", "0007_heatmapaggregate_time_slice"),
+    ]
+
+    operations = [
+        migrations.AlterField(
+            model_name="analyticsaggregate",
+            name="side",
+            field=models.CharField(
+                choices=[("t", "T"), ("ct", "CT"), ("all", "ALL")],
+                default="all",
+                max_length=3,
+            ),
+        ),
+        migrations.AlterField(
+            model_name="heatmapaggregate",
+            name="side",
+            field=models.CharField(
+                choices=[("t", "T"), ("ct", "CT"), ("all", "ALL")],
+                default="all",
+                max_length=3,
+            ),
+        ),
+        migrations.RunPython(normalize_values, noop_reverse),
+    ]
diff --git a/faceit_analytics/models.py b/faceit_analytics/models.py
index 4cd260cb2c95a28372b219cb6908136bc12903a2..3bd1fce4762b517a59833af6189a469ba7b8fec1 100644
--- a/faceit_analytics/models.py
+++ b/faceit_analytics/models.py
@@ -1,35 +1,35 @@
 from django.conf import settings
 from django.db import models
 
 from users.models import PlayerProfile
 
 
 class AnalyticsAggregate(models.Model):
-    SIDE_ALL = "ALL"
-    SIDE_CT = "CT"
-    SIDE_T = "T"
+    SIDE_ALL = "all"
+    SIDE_CT = "ct"
+    SIDE_T = "t"
 
     SIDE_CHOICES = (
         (SIDE_T, "T"),
         (SIDE_CT, "CT"),
         (SIDE_ALL, "ALL"),
     )
 
     profile = models.ForeignKey(PlayerProfile, on_delete=models.CASCADE, related_name="analytics_aggregates")
     map_name = models.CharField(max_length=64)
     side = models.CharField(max_length=3, choices=SIDE_CHOICES, default=SIDE_ALL)
     period = models.CharField(max_length=20)
     analytics_version = models.CharField(max_length=12, default="v1")
     metrics_json = models.JSONField(default=dict)
     updated_at = models.DateTimeField(auto_now=True)
 
     class Meta:
         unique_together = ("profile", "map_name", "side", "period", "analytics_version")
 
     def __str__(self) -> str:
         return f"AnalyticsAggregate({self.profile_id}, {self.map_name}, {self.side}, {self.period})"
 
 
 def heatmap_upload_to(instance: "HeatmapAggregate", filename: str) -> str:
     return (
         "heatmaps/"
diff --git a/faceit_analytics/services/archetype.py b/faceit_analytics/services/archetype.py
index 6e3610a6797499a0beb2db4e922225ef1e0c21d6..4deb5ce70a6b2f31c6dc6b7ded0f49a065ade898 100644
--- a/faceit_analytics/services/archetype.py
+++ b/faceit_analytics/services/archetype.py
@@ -44,55 +44,110 @@ def infer_archetype(metrics: dict[str, Any], timing_slices: dict[str, Any], dist
         except (TypeError, ValueError):
             early_share = None
             late_share = None
 
     entry_score = (
         _safe_ratio(first_duel_attempts) * 1.6
         + _safe_ratio(first_contact_rate) * 1.3
         + _safe_ratio(early_share) * 1.1
     )
     support_score = (
         _safe_ratio(flash_assists) * 1.4
         + _safe_ratio(trade_kill_rate) * 1.1
         + _safe_ratio(assists_per_round) * 0.9
     )
     lurk_score = (
         _safe_ratio(late_share) * 1.4
         + (1.0 - _safe_ratio(traded_death_rate, 0.0)) * 0.8
         + (1.0 - _safe_ratio(first_duel_attempts, 0.0)) * 0.6
     )
 
     scores = {
         "Entry": entry_score,
         "Support": support_score,
         "Lurk": lurk_score,
     }
+    value_inputs = (
+        first_duel_attempts,
+        first_contact_rate,
+        trade_kill_rate,
+        traded_death_rate,
+        flash_assists,
+        assists_per_round,
+        early_share,
+        late_share,
+    )
+    if all(value is None for value in value_inputs):
+        return {
+            "label": "Unknown",
+            "label_ru": "Недостаточно данных",
+            "scores": scores,
+            "reasons": [],
+            "reasons_ru": [],
+            "explanation_ru": "Недостаточно данных для определения архетипа.",
+            "approx": True,
+            "entry_split": {
+                "with_teammate": None,
+                "solo": None,
+                "note": "Недостаточно данных",
+            },
+        }
+
     label = max(scores, key=scores.get) if scores else "Unknown"
+    label_map = {
+        "Entry": "Энтри",
+        "Support": "Саппорт",
+        "Lurk": "Лёркер",
+    }
 
     reasons: list[str] = []
+    reasons_ru: list[str] = []
     if label == "Entry":
         if first_duel_attempts is not None:
             reasons.append("High first duel attempts per round.")
+            reasons_ru.append("Часто открывает раунд и берёт первые дуэли.")
         if first_contact_rate is not None:
             reasons.append("Frequent early contacts.")
+            reasons_ru.append("Регулярно вступает в первый контакт.")
         if early_share is not None:
             reasons.append("Most contacts happen early in the round.")
+            reasons_ru.append("Большая часть контактов приходится на раннюю стадию раунда.")
     elif label == "Support":
         if flash_assists is not None:
             reasons.append("Consistent flash assists per round.")
+            reasons_ru.append("Регулярно помогает флешками.")
         if trade_kill_rate is not None:
             reasons.append("Good trade kill involvement.")
+            reasons_ru.append("Часто разменяет союзников.")
         if assists_per_round is not None:
             reasons.append("High assist volume per round.")
+            reasons_ru.append("Стабильно набирает ассисты.")
     else:
         if late_share is not None:
             reasons.append("More contacts happen late in the round.")
+            reasons_ru.append("Контакты чаще происходят в поздней стадии раунда.")
         if traded_death_rate is not None:
             reasons.append("Lower traded death rate suggests spacing.")
+            reasons_ru.append("Редко разменяется, что похоже на игру с дистанции.")
         reasons.append("Less frequent early duels.")
+        reasons_ru.append("Реже вступает в ранние дуэли.")
+
+    entry_split = (metrics or {}).get("entry_split") or {}
+    entry_with_teammate = entry_split.get("with_teammate")
+    entry_solo = entry_split.get("solo")
 
     return {
         "label": label,
+        "label_ru": label_map.get(label, "Недостаточно данных"),
         "scores": scores,
         "reasons": reasons[:3],
+        "reasons_ru": reasons_ru[:3],
+        "explanation_ru": " ".join(reasons_ru[:3]) if reasons_ru else "Недостаточно данных.",
         "approx": any(value is None for value in (first_duel_attempts, trade_kill_rate, flash_assists)),
+        "entry_split": {
+            "with_teammate": entry_with_teammate,
+            "solo": entry_solo,
+            "note": "Недостаточно данных"
+            if entry_with_teammate is None or entry_solo is None
+            else None,
+        },
     }
diff --git a/faceit_analytics/services/demo_events.py b/faceit_analytics/services/demo_events.py
index 34a36a7f6d890850767f5b3e44fbda46a8c947a9..b051408146d8166f133608f317c619152d77fd17 100644
--- a/faceit_analytics/services/demo_events.py
+++ b/faceit_analytics/services/demo_events.py
@@ -1,30 +1,32 @@
 from __future__ import annotations
 
 import hashlib
+import json
 import math
 from collections import Counter
+from functools import lru_cache
 from dataclasses import dataclass
 from pathlib import Path
 from typing import Any, Callable, Iterable
 
 import numpy as np
 import pandas as pd
 import pyarrow as pa
 import pyarrow.parquet as pq
 from awpy import Demo
 from django.conf import settings
 from django.core.cache import cache
 
 from faceit_analytics.cache_keys import demo_features_key
 from faceit_analytics.services.features import (
     compute_role_fingerprint,
     compute_timing_slices,
     compute_utility_iq,
 )
 from faceit_analytics.services.paths import get_demos_dir
 from faceit_analytics.utils import to_jsonable
 
 TRADE_WINDOW_SECONDS = 5
 FLASH_ASSIST_WINDOW_SECONDS = 4
 FIRST_CONTACT_WINDOW_SECONDS = 20
 MIN_FLASH_DURATION_SECONDS = 0.2
@@ -182,54 +184,51 @@ def steamid_eq(value: Any, target: Any) -> bool:
 
 
 def safe_json(obj: Any) -> Any:
     return to_jsonable(obj)
 
 
 def _local_demos_root(demos_dir: Path | None = None) -> Path:
     if demos_dir is not None:
         return Path(demos_dir)
     local_root = getattr(settings, "LOCAL_DEMOS_ROOT", None)
     if local_root:
         return Path(local_root)
     media_root = Path(getattr(settings, "MEDIA_ROOT", "media"))
     return media_root / "local_demos"
 
 
 def _profile_steamid64(profile) -> str:
     for attr in ("steamid64", "steam_id64", "steam_id"):
         value = getattr(profile, attr, None)
         if value:
             return str(value).strip()
     return ""
 
 
 def discover_demo_files(profile, period: str, map_name: str, demos_dir: Path | None = None) -> list[Path]:
-    if demos_dir is not None:
-        demos_root = Path(demos_dir)
-    else:
-        demos_root = get_demos_dir(profile, map_name)
+    demos_root = get_demos_dir(profile, map_name)
     steam_id = _profile_steamid64(profile)
     if not steam_id:
         return []
     if not demos_root.exists():
         return []
     demo_paths = list(demos_root.glob("*.dem"))
 
     demo_paths = sorted(demo_paths, key=lambda p: p.stat().st_mtime, reverse=True)
     limit = max(_period_to_limit(period), 1)
     return demo_paths[:limit]
 
 
 def compute_demo_set_hash(files: Iterable[Path]) -> str:
     hasher = hashlib.sha1()
     for path in sorted(files, key=lambda p: p.name):
         stats = path.stat()
         hasher.update(str(path.resolve()).encode("utf-8"))
         hasher.update(str(stats.st_size).encode("utf-8"))
         hasher.update(str(stats.st_mtime).encode("utf-8"))
     return hasher.hexdigest()
 
 
 def _tick_rate_from_demo(demo: Demo) -> float:
     for attr in ("tickrate", "tick_rate", "tickRate"):
         value = getattr(demo, attr, None)
@@ -1092,51 +1091,54 @@ def aggregate_player_features(
         "rounds": rounds_total if rounds_total else None,
         "tick_rate": tick_rate,
     }
 
     debug = {
         "player_kills": player_kills,
         "player_deaths": player_deaths,
         "player_assists": player_assists,
         "player_util_damage_total": player_utility_damage_total,
         "utility_damage_per_round": utility_damage_per_round,
         "player_contacts": player_kills + player_deaths,
         "target_attacker_kills": target_attacker_kills,
         "target_victim_deaths": target_victim_deaths,
         "target_assists": target_assists,
         "attacker_id_examples": attacker_id_examples,
         "victim_id_examples": victim_id_examples,
         "target_name": target_name,
         "name_candidates_count": len(name_candidates),
         "steam_match_counts": steam_match_counts,
     }
 
     return events, meta, debug
 
 
 def _slice_label(bounds: tuple[int, int]) -> str:
-    return f"{int(bounds[0])}-{int(bounds[1])}"
+    start, end = bounds
+    if int(end) >= 999:
+        return f"{int(start)}+"
+    return f"{int(start)}-{int(end)}"
 
 
 def _slice_for_time(seconds: float | None) -> str:
     if seconds is None:
         return "unknown"
     for bounds in HEATMAP_TIME_SLICES:
         start, end = bounds
         if start <= seconds < end:
             return _slice_label(bounds)
     last = HEATMAP_TIME_SLICES[-1]
     return _slice_label(last)
 
 
 def _rounds_from_events(events: list[dict[str, Any]]) -> int:
     rounds = {event.get("round") for event in events if event.get("round") is not None}
     return len(rounds)
 
 
 def compute_awareness_before_death(events: list[dict[str, Any]]) -> dict[str, Any]:
     deaths = [event for event in events if event.get("type") == "death" and event.get("time") is not None]
     if not deaths:
         return {
             "aware_deaths": 0,
             "total_deaths": 0,
             "awareness_before_death_rate": None,
@@ -1169,118 +1171,195 @@ def compute_awareness_before_death(events: list[dict[str, Any]]) -> dict[str, An
             aware_count += 1
             bucket["aware"] += 1
 
     total_deaths = len(deaths)
     return {
         "aware_deaths": aware_count,
         "total_deaths": total_deaths,
         "awareness_before_death_rate": (aware_count / total_deaths) * 100 if total_deaths else None,
         "by_slice": by_slice,
         "lookback_sec": DEATH_AWARENESS_LOOKBACK_SEC,
     }
 
 
 def _quadrant_from_coords(x: float | None, y: float | None) -> str:
     if x is None or y is None:
         return "unknown"
     if x >= 0 and y >= 0:
         return "NE"
     if x < 0 and y >= 0:
         return "NW"
     if x >= 0 and y < 0:
         return "SE"
     return "SW"
 
 
-def compute_multikill_metrics(events: list[dict[str, Any]]) -> dict[str, Any]:
+@lru_cache(maxsize=16)
+def _load_zone_config(map_name: str | None) -> dict[str, Any]:
+    if not map_name:
+        return {}
+    zones_path = Path(__file__).resolve().parent.parent / "maps" / "zones.json"
+    if not zones_path.exists():
+        return {}
+    try:
+        payload = json.loads(zones_path.read_text(encoding="utf-8"))
+    except json.JSONDecodeError:
+        return {}
+    return payload.get(map_name, {})
+
+
+def _normalize_place(place: str | None) -> str:
+    if not place:
+        return ""
+    return str(place).strip().lower()
+
+
+def _zone_from_place(place: str | None, config: dict[str, Any]) -> str | None:
+    if not place or not config:
+        return None
+    place_norm = _normalize_place(place)
+    for zone, tokens in (config.get("place_map") or {}).items():
+        for token in tokens:
+            if token in place_norm:
+                return zone
+    return None
+
+
+def _zone_from_coords(map_name: str | None, x: float | None, y: float | None, config: dict[str, Any]) -> str | None:
+    if not map_name or x is None or y is None or not config:
+        return None
+    bboxes = config.get("bbox") or {}
+    if not bboxes:
+        return None
+    try:
+        from faceit_analytics import analyzer
+
+        radar, meta, _radar_name = analyzer.load_radar_and_meta(map_name)
+        w, h = radar.size
+        pixel = analyzer._world_to_pixel(np.array([[x, y]], dtype=np.float32), meta, (w, h))
+        if pixel.size == 0:
+            return None
+        px, py = float(pixel[0][0]), float(pixel[0][1])
+        nx = px / max(w, 1)
+        ny = py / max(h, 1)
+    except Exception:
+        return None
+
+    for zone, boxes in bboxes.items():
+        for box in boxes:
+            x1, y1, x2, y2 = box
+            if x1 <= nx <= x2 and y1 <= ny <= y2:
+                return zone
+    return None
+
+
+def _kill_zone(kill: dict[str, Any], map_name: str | None) -> str:
+    config = _load_zone_config(map_name)
+    zone = _zone_from_place(kill.get("attacker_place"), config)
+    if zone:
+        return zone
+    zone = _zone_from_coords(map_name, kill.get("attacker_x"), kill.get("attacker_y"), config)
+    if zone:
+        return zone
+    return _quadrant_from_coords(kill.get("attacker_x"), kill.get("attacker_y"))
+
+
+def compute_multikill_metrics(events: list[dict[str, Any]], map_name: str | None = None) -> dict[str, Any]:
     kills = [event for event in events if event.get("type") == "kill" and event.get("time") is not None]
     if not kills:
         return {
             "multikill_round_rate": None,
             "multikill_event_rate": None,
             "multikill_events": 0,
             "rounds_with_multikill": 0,
             "by_timing": {"early": 0, "late": 0},
+            "by_phase": {"entry": 0, "hold": 0},
             "by_zone": {},
             "window_sec": MULTIKILL_WINDOW_SEC,
             "early_threshold_sec": MULTIKILL_EARLY_THRESHOLD_SEC,
         }
 
     rounds_with_multikill = set()
     multikill_events = 0
     timing_breakdown = {"early": 0, "late": 0}
+    phase_breakdown = {"entry": 0, "hold": 0}
     zone_breakdown: dict[str, int] = {}
 
     kills_by_round: dict[int | None, list[dict[str, Any]]] = {}
     for kill in kills:
         kills_by_round.setdefault(kill.get("round"), []).append(kill)
 
     for round_number, round_kills in kills_by_round.items():
         if round_number is None:
             continue
         sorted_kills = sorted(round_kills, key=lambda k: k.get("time") or 0)
         streak: list[dict[str, Any]] = []
         for kill in sorted_kills:
             if not streak:
                 streak = [kill]
                 continue
             delta = float(kill.get("time") or 0) - float(streak[-1].get("time") or 0)
             if delta <= MULTIKILL_WINDOW_SEC:
                 streak.append(kill)
             else:
                 if len(streak) >= 2:
                     multikill_events += 1
                     rounds_with_multikill.add(round_number)
                     start_time = float(streak[0].get("time") or 0)
                     key = "early" if start_time <= MULTIKILL_EARLY_THRESHOLD_SEC else "late"
                     timing_breakdown[key] += 1
-                    zone = streak[0].get("attacker_place") or _quadrant_from_coords(
-                        streak[0].get("attacker_x"),
-                        streak[0].get("attacker_y"),
-                    )
+                    zone = _kill_zone(streak[0], map_name)
                     zone_breakdown[zone] = zone_breakdown.get(zone, 0) + 1
+                    if zone in {"A", "B", "ENTRY"}:
+                        if start_time <= MULTIKILL_EARLY_THRESHOLD_SEC:
+                            phase_breakdown["entry"] += 1
+                        else:
+                            phase_breakdown["hold"] += 1
                 streak = [kill]
         if len(streak) >= 2:
             multikill_events += 1
             rounds_with_multikill.add(round_number)
             start_time = float(streak[0].get("time") or 0)
             key = "early" if start_time <= MULTIKILL_EARLY_THRESHOLD_SEC else "late"
             timing_breakdown[key] += 1
-            zone = streak[0].get("attacker_place") or _quadrant_from_coords(
-                streak[0].get("attacker_x"),
-                streak[0].get("attacker_y"),
-            )
+            zone = _kill_zone(streak[0], map_name)
             zone_breakdown[zone] = zone_breakdown.get(zone, 0) + 1
+            if zone in {"A", "B", "ENTRY"}:
+                if start_time <= MULTIKILL_EARLY_THRESHOLD_SEC:
+                    phase_breakdown["entry"] += 1
+                else:
+                    phase_breakdown["hold"] += 1
 
     rounds_total = _rounds_from_events(events)
     total_kills = len(kills)
     return {
         "multikill_round_rate": (multikill_events / rounds_total) * 100 if rounds_total else None,
         "multikill_event_rate": (multikill_events / total_kills) * 100 if total_kills else None,
         "multikill_events": multikill_events,
         "rounds_with_multikill": len(rounds_with_multikill),
         "by_timing": timing_breakdown,
+        "by_phase": phase_breakdown,
         "by_zone": zone_breakdown,
         "window_sec": MULTIKILL_WINDOW_SEC,
         "early_threshold_sec": MULTIKILL_EARLY_THRESHOLD_SEC,
     }
 
 
 def get_or_build_demo_features(
     profile,
     period: str,
     map_name: str,
     analytics_version: str,
     *,
     force_rebuild: bool = False,
     progress_callback: Callable[[int], None] | None = None,
     progress_start: int = 10,
     progress_end: int = 40,
 ) -> dict[str, Any]:
     steam_id = _profile_steamid64(profile)
     demo_files = discover_demo_files(profile, period, map_name)
     demos_count = len(demo_files)
     demo_set_hash = compute_demo_set_hash(demo_files) if demo_files else ""
 
     cache_key = demo_features_key(profile.id, period, map_name, demo_set_hash, analytics_version)
     if not force_rebuild:
         try:
@@ -1389,51 +1468,51 @@ def get_or_build_demo_features(
         if progress_callback:
             span = max(progress_end - progress_start, 1)
             progress = progress_start + int((index / max(demos_count, 1)) * span)
             progress_callback(progress)
 
     events, meta, player_debug = aggregate_player_features(parsed_demos, steam_id)
     debug.update(
         {
             "player_kills": player_debug.get("player_kills", 0),
             "player_deaths": player_debug.get("player_deaths", 0),
             "player_assists": player_debug.get("player_assists", 0),
             "player_util_damage_total": player_debug.get("player_util_damage_total", 0.0),
             "target_attacker_kills": player_debug.get("target_attacker_kills", 0),
             "target_victim_deaths": player_debug.get("target_victim_deaths", 0),
             "target_assists": player_debug.get("target_assists", 0),
             "attacker_id_examples": player_debug.get("attacker_id_examples", []),
             "victim_id_examples": player_debug.get("victim_id_examples", []),
             "target_name": player_debug.get("target_name"),
             "name_candidates_count": player_debug.get("name_candidates_count"),
             "steam_match_counts": player_debug.get("steam_match_counts"),
         }
     )
     rounds_total = meta.get("rounds") or 0
 
     awareness = compute_awareness_before_death(events)
-    multikill = compute_multikill_metrics(events)
+    multikill = compute_multikill_metrics(events, map_name)
 
     kills = debug.get("player_kills", 0) or 0
     deaths = debug.get("player_deaths", 0) or 0
     assists = debug.get("player_assists", 0) or 0
     kda_ratio = (kills + assists) / deaths if deaths else None
     kda = {
         "kills": kills,
         "deaths": deaths,
         "assists": assists,
         "kda_ratio": kda_ratio,
         "assists_per_round": assists / rounds_total if rounds_total else None,
     }
 
     if rounds_total < MIN_ROUNDS_REQUIRED:
         meta = {
             "rounds": None,
             "period": period,
             "profile_id": profile.id,
             "min_rounds_required": MIN_ROUNDS_REQUIRED,
             "minimal_contacts": MIN_CONTACTS_REQUIRED,
             "player_kills": debug.get("player_kills", 0),
             "player_deaths": debug.get("player_deaths", 0),
             "flash_events_count": debug.get("flash_events_count", 0),
             "tickrate_assumed": debug.get("tickrate_assumed"),
         }
diff --git a/faceit_analytics/services/features.py b/faceit_analytics/services/features.py
index c24161cce956090184b96de74885f7d1e3cbb86f..58694bb67d0d94fc4e350bd006b62af7733822d8 100644
--- a/faceit_analytics/services/features.py
+++ b/faceit_analytics/services/features.py
@@ -351,86 +351,85 @@ def _utility_iq_score(
     return score
 
 
 def _build_role_tags(metrics: dict[str, dict[str, Any]], meta: dict[str, Any]) -> list[str]:
     def _value(name: str) -> float | None:
         metric = metrics.get(name) or {}
         return metric.get("value")
 
     tags: list[str] = []
     first_duel_attempts = _value("first_duel_attempts_per_round")
     early_contacts = None
     timing_meta = meta.get("timing_slices")
     if timing_meta and isinstance(timing_meta, dict):
         for bucket in timing_meta.get("buckets", []):
             if bucket.get("label") == "0-30":
                 early_contacts = bucket.get("value")
                 break
     traded_death_rate = _value("traded_death_rate")
     flash_assists = _value("flash_assists_per_round")
     utility_damage = _value("utility_damage_per_round")
     clutch_opportunities = _value("clutch_opportunities_rate")
     clutch_win = _value("clutch_win_rate")
 
     if first_duel_attempts is not None and first_duel_attempts >= 0.14:
         if early_contacts is None or early_contacts >= 40:
-            tags.append("Aggressive Entry")
+            tags.append("Агрессивный энтри")
 
     if first_duel_attempts is not None and first_duel_attempts >= 0.14:
         if traded_death_rate is not None and traded_death_rate < 0.3:
-            tags.append("Low Trade Synergy")
+            tags.append("Слабые размены")
 
     if (flash_assists is not None and flash_assists >= 0.12) or (
         utility_damage is not None and utility_damage >= 18
     ):
-        tags.append("Support Utility")
+        tags.append("Поддержка утилити")
 
     if clutch_opportunities is not None and clutch_opportunities >= 0.08:
         if clutch_win is not None and clutch_win >= 0.4:
-            tags.append("Clutch Factor")
+            tags.append("Клатч-фактор")
 
     if meta.get("side") == "CT":
         if early_contacts is not None and early_contacts < 25:
-            tags.append("Passive Anchor")
+            tags.append("Пассивный якорь")
 
     return tags[:5]
 
 
 def _build_role_summary(metrics: dict[str, dict[str, Any]], tags: list[str], meta: dict[str, Any]) -> str:
     rounds = meta.get("rounds")
     min_rounds_required = meta.get("min_rounds_required")
     minimal_contacts = meta.get("minimal_contacts")
     player_kills = meta.get("player_kills")
     player_deaths = meta.get("player_deaths")
     contacts = None
     if player_kills is not None and player_deaths is not None:
         contacts = int(player_kills) + int(player_deaths)
 
     insufficient_rounds = False
     if min_rounds_required is not None:
         if rounds is None or rounds < int(min_rounds_required):
             insufficient_rounds = True
     insufficient_contacts = (
         minimal_contacts is not None and contacts is not None and contacts < int(minimal_contacts)
     )
 
     if insufficient_rounds or insufficient_contacts:
-        return "Not enough data to build a stable role fingerprint."
+        return "Недостаточно данных для стабильного ролевого профиля."
 
     if not tags:
-        summary = "Role profile is developing based on available contacts."
+        summary = "Ролевой профиль формируется по доступным контактам."
     else:
         primary = tags[0]
         second = tags[1] if len(tags) > 1 else None
-        summary = f"{primary} tendencies"
+        summary = f"Основной профиль: {primary}."
         if second:
-            summary += f" with {second.lower()} patterns"
-        summary += "."
+            summary += f" Также заметны признаки: {second.lower()}."
 
     first_duel_success = metrics.get("first_duel_success_rate", {}).get("value")
     if first_duel_success is not None:
-        summary += f" First-duel success rate is {first_duel_success:.0%}."
+        summary += f" Успех первых дуэлей: {first_duel_success:.0%}."
 
     if meta.get("flash_events_count") == 0:
-        summary += " Note: no flash events detected, so flash-related metrics may be missing."
+        summary += " Флеш-события не найдены, поэтому метрики флешей могут отсутствовать."
 
     return summary
diff --git a/faceit_analytics/services/heatmaps.py b/faceit_analytics/services/heatmaps.py
index 38fd41e1c5b79a9a192980553c4769228799a46e..2bf04f331b08f207d8cac13614f3e43fdf7348bd 100644
--- a/faceit_analytics/services/heatmaps.py
+++ b/faceit_analytics/services/heatmaps.py
@@ -1,130 +1,235 @@
 from __future__ import annotations
 
 import hashlib
+import logging
 import os
 import time
 from pathlib import Path
 from typing import Iterable, Sequence
 from uuid import uuid4
 
 import numpy as np
 from django.conf import settings
 from django.core.files.storage import default_storage
 from django.db import transaction
 from django.utils import timezone
 from matplotlib import cm
 from PIL import Image, ImageFilter
 
 from faceit_analytics import analyzer
 from faceit_analytics.constants import ANALYTICS_VERSION
 from faceit_analytics.models import AnalyticsAggregate, HeatmapAggregate, heatmap_upload_to
 from faceit_analytics.services.paths import get_demos_dir
 from faceit_analytics.utils import to_jsonable
 from users.models import PlayerProfile
 
 DEFAULT_MAPS: Iterable[str] = ("de_mirage",)
 
+logger = logging.getLogger(__name__)
+
 # Output image size (radar+heatmap)
 HEATMAP_OUTPUT_SIZE = int(getattr(settings, "HEATMAP_OUTPUT_SIZE", 1024))
 
 # Upscale filter for resizing
 HEATMAP_UPSCALE_FILTER = str(getattr(settings, "HEATMAP_UPSCALE_FILTER", "LANCZOS")).upper()
 
 # IMPORTANT: blur sigma is now interpreted in GRID units (cells), not pixels.
 # For res=64: sigma 0.8..1.4 is typical. For "kills/deaths dots": lower.
 # Backward compatible env names:
 HEATMAP_BLUR_SIGMA_GRID = float(
     getattr(
         settings,
         "HEATMAP_BLUR_SIGMA_GRID",
         getattr(
             settings,
             "HEATMAP_BLUR_SIGMA",
             getattr(settings, "HEATMAP_BLUR_FACTOR", getattr(settings, "HEATMAP_BLUR_RADIUS", 0.0)),
         ),
     )
 )
 
 # Optional post-upscale blur in output pixel space (default disabled)
 HEATMAP_BLUR_SIGMA_OUTPUT = float(getattr(settings, "HEATMAP_BLUR_SIGMA_OUTPUT", 0.0))
 
 # Per-metric blur overrides (optional)
-HEATMAP_BLUR_SIGMA_KILLS = float(getattr(settings, "HEATMAP_BLUR_SIGMA_KILLS", HEATMAP_BLUR_SIGMA_GRID))
-HEATMAP_BLUR_SIGMA_DEATHS = float(getattr(settings, "HEATMAP_BLUR_SIGMA_DEATHS", HEATMAP_BLUR_SIGMA_GRID))
-HEATMAP_BLUR_SIGMA_PRESENCE = float(getattr(settings, "HEATMAP_BLUR_SIGMA_PRESENCE", HEATMAP_BLUR_SIGMA_GRID))
+HEATMAP_BLUR_SIGMA_KILLS = float(getattr(settings, "HEATMAP_BLUR_SIGMA_KILLS", HEATMAP_BLUR_SIGMA_GRID * 0.7))
+HEATMAP_BLUR_SIGMA_DEATHS = float(getattr(settings, "HEATMAP_BLUR_SIGMA_DEATHS", HEATMAP_BLUR_SIGMA_GRID * 0.7))
+HEATMAP_BLUR_SIGMA_PRESENCE = float(
+    getattr(settings, "HEATMAP_BLUR_SIGMA_PRESENCE", HEATMAP_BLUR_SIGMA_GRID * 1.15)
+)
 
 # Percentile clip for normalization (higher -> less saturation)
 HEATMAP_NORM_PERCENTILE = float(
     getattr(
         settings,
         "HEATMAP_NORM_PERCENTILE",
         getattr(settings, "HEATMAP_PERCENTILE_CLIP", getattr(settings, "HEATMAP_CLIP_PCT", 99.5)),
     )
 )
 
 # Gamma (lower -> brighter tails, higher -> more contrast)
 HEATMAP_GAMMA = float(getattr(settings, "HEATMAP_GAMMA", 0.75))
+HEATMAP_GAMMA_KILLS = float(getattr(settings, "HEATMAP_GAMMA_KILLS", HEATMAP_GAMMA + 0.15))
+HEATMAP_GAMMA_DEATHS = float(getattr(settings, "HEATMAP_GAMMA_DEATHS", HEATMAP_GAMMA + 0.1))
+HEATMAP_GAMMA_PRESENCE = float(getattr(settings, "HEATMAP_GAMMA_PRESENCE", max(0.35, HEATMAP_GAMMA - 0.1)))
 
 # Global alpha multiplier
 HEATMAP_ALPHA = float(getattr(settings, "HEATMAP_ALPHA", 0.98))
+HEATMAP_ALPHA_KILLS = float(getattr(settings, "HEATMAP_ALPHA_KILLS", HEATMAP_ALPHA))
+HEATMAP_ALPHA_DEATHS = float(getattr(settings, "HEATMAP_ALPHA_DEATHS", HEATMAP_ALPHA))
+HEATMAP_ALPHA_PRESENCE = float(getattr(settings, "HEATMAP_ALPHA_PRESENCE", max(0.85, HEATMAP_ALPHA - 0.05)))
+
+HEATMAP_CLIP_PCT_KILLS = float(getattr(settings, "HEATMAP_CLIP_PCT_KILLS", HEATMAP_NORM_PERCENTILE))
+HEATMAP_CLIP_PCT_DEATHS = float(getattr(settings, "HEATMAP_CLIP_PCT_DEATHS", HEATMAP_NORM_PERCENTILE))
+HEATMAP_CLIP_PCT_PRESENCE = float(getattr(settings, "HEATMAP_CLIP_PCT_PRESENCE", HEATMAP_NORM_PERCENTILE))
 
 # Alpha curve power (lower -> more visible faint areas)
 HEATMAP_ALPHA_POWER = float(getattr(settings, "HEATMAP_ALPHA_POWER", 0.55))
 
 # Optional unsharp to increase clarity after resize (0 disables)
 HEATMAP_UNSHARP_RADIUS = float(getattr(settings, "HEATMAP_UNSHARP_RADIUS", 0.0))
 HEATMAP_UNSHARP_PERCENT = int(getattr(settings, "HEATMAP_UNSHARP_PERCENT", 140))
 HEATMAP_UNSHARP_THRESHOLD = int(getattr(settings, "HEATMAP_UNSHARP_THRESHOLD", 2))
 
 HEATMAP_TIME_SLICES = list(getattr(settings, "HEATMAP_TIME_SLICES", [(0, 999)]))
 HEATMAP_DEFAULT_SLICE = str(getattr(settings, "HEATMAP_DEFAULT_SLICE", "all"))
 
+DEFAULT_PERIOD = "last_20"
 
-def _slice_label(slice_range: tuple[int, int]) -> str:
-    return f"{int(slice_range[0])}-{int(slice_range[1])}"
 
+def _slice_label(slice_range: tuple[int, int | None]) -> str:
+    start, end = slice_range
+    if end is None or int(end) >= 999:
+        return f"{int(start)}+"
+    return f"{int(start)}-{int(end)}"
 
-def _get_time_slice_ranges() -> dict[str, tuple[int, int]]:
-    ranges: dict[str, tuple[int, int]] = {}
+
+def _get_time_slice_ranges() -> dict[str, tuple[int, int | None]]:
+    ranges: dict[str, tuple[int, int | None]] = {}
     for start, end in HEATMAP_TIME_SLICES:
-        ranges[_slice_label((start, end))] = (int(start), int(end))
+        normalized_end = None if end is None or int(end) >= 999 else int(end)
+        ranges[_slice_label((start, end))] = (int(start), normalized_end)
     return ranges
 
 
 def normalize_time_slice(value: str | None) -> str:
     if not value:
         return HEATMAP_DEFAULT_SLICE
     value = str(value).strip()
     if not value:
         return HEATMAP_DEFAULT_SLICE
     if value.lower() == "all":
         return "all"
+    parsed = parse_time_slice(value)
+    if parsed is None:
+        return HEATMAP_DEFAULT_SLICE
+    start, end = parsed
+    return _slice_label((start, end))
+
+
+def parse_time_slice(value: str | None) -> tuple[int, int | None] | None:
+    if not value:
+        return None
+    value = str(value).strip().lower()
+    if not value or value == "all":
+        return None
     ranges = _get_time_slice_ranges()
     if value in ranges:
-        return value
-    return HEATMAP_DEFAULT_SLICE
+        return ranges[value]
+    if "+" in value:
+        start = value.replace("+", "").strip()
+        if start.isdigit():
+            return int(start), None
+        return None
+    if "-" in value:
+        parts = value.split("-", 1)
+        if len(parts) != 2:
+            return None
+        start, end = parts
+        if start.strip().isdigit() and end.strip().isdigit():
+            return int(start), int(end)
+    return None
+
+
+def get_time_slice_labels() -> list[str]:
+    ranges = _get_time_slice_ranges()
+    labels = []
+    for start, end in HEATMAP_TIME_SLICES:
+        labels.append(_slice_label((int(start), int(end) if end is not None else None)))
+    return labels or ["0-15"]
+
+
+def normalize_side(value: str | None) -> str:
+    if not value:
+        return AnalyticsAggregate.SIDE_ALL
+    value_str = str(value).strip().lower()
+    if value_str in {"ct", "counterterrorist", "counter-terrorist", "counter_terrorist"}:
+        return AnalyticsAggregate.SIDE_CT
+    if value_str in {"t", "terrorist"}:
+        return AnalyticsAggregate.SIDE_T
+    if value_str in {"all", "any", "both"}:
+        return AnalyticsAggregate.SIDE_ALL
+    return AnalyticsAggregate.SIDE_ALL
+
+
+def normalize_metric(value: str | None) -> str:
+    if not value:
+        return HeatmapAggregate.METRIC_KILLS
+    value_str = str(value).strip().lower()
+    if value_str in {"kills", "kill"}:
+        return HeatmapAggregate.METRIC_KILLS
+    if value_str in {"deaths", "death"}:
+        return HeatmapAggregate.METRIC_DEATHS
+    if value_str in {"presence", "pos", "positions"}:
+        return HeatmapAggregate.METRIC_PRESENCE
+    return HeatmapAggregate.METRIC_KILLS
+
+
+def normalize_period(value: str | None) -> str:
+    if not value:
+        return DEFAULT_PERIOD
+    value_str = str(value).strip().lower()
+    if value_str in {"last_20", "20", "recent"}:
+        return "last_20"
+    if value_str in {"last_50", "50"}:
+        return "last_50"
+    if value_str in {"all_time", "all", "alltime"}:
+        return "all_time"
+    return DEFAULT_PERIOD
+
+
+def normalize_map_name(value: str | None) -> str:
+    if not value:
+        return next(iter(DEFAULT_MAPS), "de_mirage")
+    return str(value).strip().lower()
+
+
+def normalize_version(value: str | None) -> str:
+    if not value:
+        return ANALYTICS_VERSION
+    return str(value).strip().lower()
 
 
 def _period_to_limit(period: str) -> int:
     mapping = {"last_20": 20, "last_50": 50, "all_time": 200}
     return mapping.get(period, 5)
 
 
 def _profile_steamid64(profile) -> str:
     for attr in ("steamid64", "steam_id64", "steam_id"):
         value = getattr(profile, attr, None)
         if value:
             return str(value).strip()
     return ""
 
 
 def _get_resample_filter(filter_name: str | None) -> int:
     name = (filter_name or HEATMAP_UPSCALE_FILTER).upper()
     return {
         "NEAREST": Image.Resampling.NEAREST,
         "BILINEAR": Image.Resampling.BILINEAR,
         "BICUBIC": Image.Resampling.BICUBIC,
         "LANCZOS": Image.Resampling.LANCZOS,
     }.get(name, Image.Resampling.LANCZOS)
 
 
@@ -184,58 +289,80 @@ def _convolve1d_reflect(arr: np.ndarray, kernel: np.ndarray, axis: int) -> np.nd
     pad_width = [(0, 0)] * arr.ndim
     pad_width[axis] = (pad, pad)
     padded = np.pad(arr, pad_width, mode="reflect")
     # convolve along axis
     out = np.apply_along_axis(lambda m: np.convolve(m, kernel, mode="valid"), axis, padded)
     return out.astype(np.float32, copy=False)
 
 
 def _gaussian_blur_grid(arr: np.ndarray, sigma_grid: float) -> np.ndarray:
     if sigma_grid <= 0:
         return arr
     k = _gaussian_kernel1d(float(sigma_grid))
     out = _convolve1d_reflect(arr, k, axis=0)
     out = _convolve1d_reflect(out, k, axis=1)
     return out
 
 
 def _metric_blur_sigma(metric: str) -> float:
     if metric == HeatmapAggregate.METRIC_KILLS:
         return HEATMAP_BLUR_SIGMA_KILLS
     if metric == HeatmapAggregate.METRIC_DEATHS:
         return HEATMAP_BLUR_SIGMA_DEATHS
     return HEATMAP_BLUR_SIGMA_PRESENCE
 
 
+def _metric_render_defaults(metric: str) -> dict[str, float]:
+    if metric == HeatmapAggregate.METRIC_KILLS:
+        return {
+            "gamma": HEATMAP_GAMMA_KILLS,
+            "alpha": HEATMAP_ALPHA_KILLS,
+            "clip": HEATMAP_CLIP_PCT_KILLS,
+        }
+    if metric == HeatmapAggregate.METRIC_DEATHS:
+        return {
+            "gamma": HEATMAP_GAMMA_DEATHS,
+            "alpha": HEATMAP_ALPHA_DEATHS,
+            "clip": HEATMAP_CLIP_PCT_DEATHS,
+        }
+    return {
+        "gamma": HEATMAP_GAMMA_PRESENCE,
+        "alpha": HEATMAP_ALPHA_PRESENCE,
+        "clip": HEATMAP_CLIP_PCT_PRESENCE,
+    }
+
+
 def render_heatmap_image(
     grid: list[list[float]],
     *,
     output_size: int | None = None,
     blur_sigma_grid: float | None = None,
     blur_sigma_output: float | None = None,
     clip_pct: float | None = None,
     gamma: float | None = None,
+    alpha: float | None = None,
+    alpha_power: float | None = None,
     upscale_filter: str | None = None,
     cmap_name: str = analyzer.CMAP_ALL,
 ) -> Image.Image:
     h = len(grid)
     w = len(grid[0]) if grid else 0
     if not w or not h:
         raise ValueError("Grid is empty")
 
     target_size = int(max(output_size or HEATMAP_OUTPUT_SIZE, 1))
 
     arr = np.array(grid, dtype=np.float32)
     arr = np.nan_to_num(arr, nan=0.0, posinf=0.0, neginf=0.0)
     arr[arr < 0] = 0.0
 
     # blur in GRID space (res units) BEFORE resizing, to keep details crisp
     sigma = float(blur_sigma_grid) if blur_sigma_grid is not None else float(HEATMAP_BLUR_SIGMA_GRID)
     if sigma > 0:
         arr = _gaussian_blur_grid(arr, sigma_grid=sigma)
 
     # resize float mask to target_size (still float32)
     if target_size != w or target_size != h:
         resample = _get_resample_filter(upscale_filter)
         mask_f = Image.fromarray(arr, mode="F").resize((target_size, target_size), resample=resample)
         arr = np.array(mask_f, dtype=np.float32)
         arr = np.nan_to_num(arr, nan=0.0, posinf=0.0, neginf=0.0)
@@ -243,150 +370,161 @@ def render_heatmap_image(
 
     # optional blur in OUTPUT pixel space (post-upscale)
     sigma_output = float(blur_sigma_output) if blur_sigma_output is not None else float(HEATMAP_BLUR_SIGMA_OUTPUT)
     if sigma_output > 0:
         arr = _gaussian_blur_grid(arr, sigma_grid=sigma_output)
 
     # normalize using percentile of positive values
     pos = arr[arr > 0]
     pct = float(clip_pct) if clip_pct is not None else float(HEATMAP_NORM_PERCENTILE)
     clip_value = float(np.percentile(pos, pct)) if pos.size else float(arr.max())
     if not clip_value or clip_value <= 0:
         clip_value = 1.0
     mask = np.clip(arr / clip_value, 0.0, 1.0)
 
     # gamma
     g = float(gamma) if gamma is not None else float(HEATMAP_GAMMA)
     if g > 0:
         mask = mask ** g
 
     # colormap to RGBA
     cmap = cm.get_cmap(cmap_name)
     rgba = cmap(mask)  # float64
     rgba = rgba.astype(np.float32)
 
     # alpha curve (controls visibility on top of radar)
-    alpha_mul = float(max(0.0, HEATMAP_ALPHA))
-    alpha_pow = float(max(0.01, HEATMAP_ALPHA_POWER))
+    alpha_mul = float(max(0.0, alpha if alpha is not None else HEATMAP_ALPHA))
+    alpha_pow = float(max(0.01, alpha_power if alpha_power is not None else HEATMAP_ALPHA_POWER))
     rgba[:, :, 3] = np.clip((mask ** alpha_pow) * alpha_mul, 0.0, 1.0)
 
     out = (rgba * 255.0).clip(0, 255).astype(np.uint8)
     img = Image.fromarray(out, mode="RGBA")
 
     # optional unsharp to enhance details without “pixelation”
     if HEATMAP_UNSHARP_RADIUS and HEATMAP_UNSHARP_RADIUS > 0:
         img = img.filter(
             ImageFilter.UnsharpMask(
                 radius=float(HEATMAP_UNSHARP_RADIUS),
                 percent=int(HEATMAP_UNSHARP_PERCENT),
                 threshold=int(HEATMAP_UNSHARP_THRESHOLD),
             )
         )
     return img
 
 
 def _build_heatmap_filename(aggregate: HeatmapAggregate, grid_array: np.ndarray) -> str:
     digest = hashlib.sha256(grid_array.tobytes()).hexdigest()[:8]
     timestamp = time.time_ns()
     return (
         f"heatmap_{aggregate.analytics_version}_{aggregate.metric}_slice{aggregate.time_slice}_"
         f"res{aggregate.resolution}_"
         f"out{HEATMAP_OUTPUT_SIZE}_{digest}_{timestamp}.png"
     )
 
 
 def _atomic_write_png(final_path: Path, render_callable) -> None:
     final_path.parent.mkdir(parents=True, exist_ok=True)
     tmp_path = final_path.with_name(f"{final_path.name}.tmp.{uuid4().hex}")
     try:
         render_callable(tmp_path)
         os.replace(tmp_path, final_path)
     finally:
         if tmp_path.exists():
             try:
                 tmp_path.unlink()
             except OSError:
                 pass
 
 
 def ensure_heatmap_image(
     aggregate: HeatmapAggregate,
     *,
     radar_path: Path | None = None,
     force: bool = False,
+    blur: float | None = None,
+    gamma: float | None = None,
+    alpha: float | None = None,
+    clip_pct: float | None = None,
 ) -> HeatmapAggregate:
     storage = aggregate.image.storage if aggregate.image else default_storage
 
     # if file missing -> force regenerate
     if aggregate.image and aggregate.image.name:
         try:
             exists = storage.exists(aggregate.image.name)
         except Exception:
             exists = False
         if not exists:
             aggregate.image = None
             force = True
 
     # if force -> remove old file if possible
     if aggregate.image and force:
         try:
             storage.delete(aggregate.image.name)
         except Exception:
             pass
         aggregate.image = None
 
     if aggregate.image and not force:
         return aggregate
 
     if not aggregate.grid:
         return aggregate
 
     media_root = Path(getattr(settings, "MEDIA_ROOT", "media"))
     media_root.mkdir(parents=True, exist_ok=True)
 
     # choose cmap by metric
     if aggregate.metric == HeatmapAggregate.METRIC_KILLS:
         cmap_name = analyzer.CMAP_KILLS
     elif aggregate.metric == HeatmapAggregate.METRIC_DEATHS:
         cmap_name = analyzer.CMAP_DEATHS
     else:
         cmap_name = {
             AnalyticsAggregate.SIDE_CT: analyzer.CMAP_CT,
             AnalyticsAggregate.SIDE_T: analyzer.CMAP_T,
             AnalyticsAggregate.SIDE_ALL: analyzer.CMAP_ALL,
         }.get(aggregate.side, analyzer.CMAP_ALL)
 
-    # IMPORTANT: use per-metric sigma in GRID units
-    blur_sigma = _metric_blur_sigma(aggregate.metric)
+    # IMPORTANT: use per-metric sigma in output pixel space, scaled by resolution
+    blur_base = float(blur) if blur is not None else _metric_blur_sigma(aggregate.metric)
+    resolution = max(int(aggregate.resolution or 1), 1)
+    blur_sigma_output = blur_base * (HEATMAP_OUTPUT_SIZE / resolution)
+    render_defaults = _metric_render_defaults(aggregate.metric)
+    gamma_value = gamma if gamma is not None else render_defaults["gamma"]
+    alpha_value = alpha if alpha is not None else render_defaults["alpha"]
+    clip_value = clip_pct if clip_pct is not None else render_defaults["clip"]
 
     heatmap_image = render_heatmap_image(
         aggregate.grid,
         output_size=HEATMAP_OUTPUT_SIZE,
-        blur_sigma_grid=blur_sigma,
-        blur_sigma_output=HEATMAP_BLUR_SIGMA_OUTPUT,
-        clip_pct=HEATMAP_NORM_PERCENTILE,
-        gamma=HEATMAP_GAMMA,
+        blur_sigma_grid=0.0,
+        blur_sigma_output=blur_sigma_output,
+        clip_pct=clip_value,
+        gamma=gamma_value,
+        alpha=alpha_value,
         upscale_filter=HEATMAP_UPSCALE_FILTER,
         cmap_name=cmap_name,
     )
 
     # load radar
     radar_image = None
     if radar_path:
         try:
             radar_image = Image.open(radar_path).convert("RGBA")
         except OSError:
             radar_image = None
     if radar_image is None:
         try:
             radar_image, _meta, _radar_name = analyzer.load_radar_and_meta(aggregate.map_name)
             radar_image = radar_image.convert("RGBA")
         except Exception:
             radar_image = None
 
     # composite
     if radar_image is not None:
         radar_image = radar_image.resize(
             (heatmap_image.width, heatmap_image.height),
             resample=_get_resample_filter(HEATMAP_UPSCALE_FILTER),
         )
         composite = Image.alpha_composite(radar_image, heatmap_image)
@@ -407,99 +545,118 @@ def ensure_heatmap_image(
     aggregate.save(update_fields=["image", "updated_at"])
     return aggregate
 
 
 def _collect_points_from_cache(
     demos_dir: Path,
     steamid64: str,
     map_name: str,
     period: str,
     side: str,
     metric: str,
     time_slice: str,
 ) -> tuple[list[tuple[float, float, float]], tuple[int, int]]:
     media_root = Path(getattr(settings, "MEDIA_ROOT", "media"))
     cache_dir = media_root / "heatmaps_cache" / steamid64 / map_name
     out_dir = media_root / "heatmaps_local" / steamid64 / "aggregate" / map_name
 
     demo_paths = sorted(demos_dir.glob("*.dem"), key=lambda p: p.stat().st_mtime, reverse=True)
     demo_paths = demo_paths[: max(_period_to_limit(period), 1)]
     if not demo_paths:
         return [], (0, 0)
 
     radar, _meta, radar_name = analyzer.load_radar_and_meta(map_name)
     radar_size = radar.size
 
-    if metric == HeatmapAggregate.METRIC_PRESENCE or time_slice == "all":
-        cache_dir.mkdir(parents=True, exist_ok=True)
-        cache_paths: list[Path] = []
-        for dem_path in demo_paths:
-            cache_name = analyzer._demo_cache_hash(dem_path, radar_name, radar_size)
-            cache_paths.append(cache_dir / f"{cache_name}.npz")
-
-        if not all(path.exists() for path in cache_paths):
-            analyzer.build_heatmaps_aggregate(
-                steamid64=steamid64,
-                map_name=map_name,
-                limit=_period_to_limit(period),
-                demos_dir=demos_dir,
-                out_dir=out_dir,
-                cache_dir=media_root / "heatmaps_cache",
-            )
+    cache_dir.mkdir(parents=True, exist_ok=True)
+    cache_paths: list[Path] = []
+    for dem_path in demo_paths:
+        cache_name = analyzer._demo_cache_hash(dem_path, radar_name, radar_size)
+        cache_paths.append(cache_dir / f"{cache_name}.npz")
+
+    if not all(path.exists() for path in cache_paths):
+        analyzer.build_heatmaps_aggregate(
+            steamid64=steamid64,
+            map_name=map_name,
+            limit=_period_to_limit(period),
+            demos_dir=demos_dir,
+            out_dir=out_dir,
+            cache_dir=media_root / "heatmaps_cache",
+        )
 
-        points: list[tuple[float, float, float]] = []
-        if metric == HeatmapAggregate.METRIC_KILLS:
-            array_key = "kills_px"
-        elif metric == HeatmapAggregate.METRIC_DEATHS:
-            array_key = "deaths_px"
-        else:
-            array_key = {
-                AnalyticsAggregate.SIDE_ALL: "presence_all_px",
-                AnalyticsAggregate.SIDE_CT: "presence_ct_px",
-                AnalyticsAggregate.SIDE_T: "presence_t_px",
-            }.get(side, "presence_all_px")
-
-        for cache_path in cache_paths:
-            if not cache_path.exists():
-                continue
-            with np.load(cache_path) as cached:
+    points: list[tuple[float, float, float]] = []
+    if metric == HeatmapAggregate.METRIC_KILLS:
+        array_key = "kills_px"
+        array_key_time = "kills_pxt"
+    elif metric == HeatmapAggregate.METRIC_DEATHS:
+        array_key = "deaths_px"
+        array_key_time = "deaths_pxt"
+    else:
+        array_key = {
+            AnalyticsAggregate.SIDE_ALL: "presence_all_px",
+            AnalyticsAggregate.SIDE_CT: "presence_ct_px",
+            AnalyticsAggregate.SIDE_T: "presence_t_px",
+        }.get(side, "presence_all_px")
+        array_key_time = {
+            AnalyticsAggregate.SIDE_ALL: "presence_all_pxt",
+            AnalyticsAggregate.SIDE_CT: "presence_ct_pxt",
+            AnalyticsAggregate.SIDE_T: "presence_t_pxt",
+        }.get(side, "presence_all_pxt")
+
+    slice_range = parse_time_slice(time_slice)
+    for cache_path in cache_paths:
+        if not cache_path.exists():
+            continue
+        with np.load(cache_path) as cached:
+            data = cached.get(array_key_time)
+            if data is None or data.size == 0:
                 data = cached.get(array_key)
                 if data is None:
                     continue
+                if slice_range:
+                    logger.debug(
+                        "Heatmap cache missing time slice data for %s, slice=%s",
+                        cache_path.name,
+                        time_slice,
+                    )
                 for x, y in data.tolist():
                     points.append((float(x), float(y), 1.0))
+                continue
+            for row in data.tolist():
+                if len(row) < 3:
+                    continue
+                x, y, t_round = row
+                if slice_range:
+                    start_sec, end_sec = slice_range
+                    if t_round is None:
+                        continue
+                    if end_sec is not None and not (start_sec <= t_round < end_sec):
+                        continue
+                    if end_sec is None and t_round < start_sec:
+                        continue
+                points.append((float(x), float(y), 1.0))
 
-        return points, radar_size
-
-    points = _collect_time_sliced_points(
-        demo_paths,
-        steamid64,
-        map_name,
-        metric,
-        time_slice,
-        radar_size,
-    )
     return points, radar_size
 
 
 def _collect_time_sliced_points(
     demo_paths: Sequence[Path],
     steamid64: str,
     map_name: str,
     metric: str,
     time_slice: str,
     radar_size: tuple[int, int],
 ) -> list[tuple[float, float, float]]:
     from faceit_analytics.services import demo_events
 
     ranges = _get_time_slice_ranges()
     slice_range = ranges.get(time_slice)
     if not slice_range:
         slice_range = ranges.get(HEATMAP_DEFAULT_SLICE, (0, 999))
     start_sec, end_sec = slice_range
 
     radar, meta, _radar_name = analyzer.load_radar_and_meta(map_name)
     points: list[tuple[float, float, float]] = []
 
     for dem_path in demo_paths:
         demo = analyzer.Demo(str(dem_path), verbose=False)
         demo.parse()
@@ -526,91 +683,102 @@ def _collect_time_sliced_points(
             if not attacker_col:
                 continue
             filtered = analyzer._filter_by_steamid_numeric(kills_df, attacker_col, steamid64)
         else:
             x_col = demo_events._pick_column(kills_df, ["victim_X", "victim_x"])
             y_col = demo_events._pick_column(kills_df, ["victim_Y", "victim_y"])
             if not victim_col:
                 continue
             filtered = analyzer._filter_by_steamid_numeric(kills_df, victim_col, steamid64)
 
         if filtered.empty or not x_col or not y_col:
             continue
 
         for _, row in filtered.iterrows():
             round_number = demo_events._safe_int(row.get(round_col)) if round_col else None
             tick_value = demo_events._safe_int(row.get(tick_col)) if tick_col else None
             t_round = demo_events._round_time_seconds(
                 row, round_number, round_start_ticks, round_start_times, tick_rate
             )
             if t_round is None and tick_value is not None:
                 start_tick = round_start_ticks.get(round_number) if round_number is not None else None
                 if start_tick is not None and tick_rate:
                     t_round = max((tick_value - start_tick) / tick_rate, 0.0)
             if t_round is None:
                 continue
-            if not (start_sec <= t_round < end_sec):
-                continue
+            if end_sec is not None:
+                if not (start_sec <= t_round < end_sec):
+                    continue
+            else:
+                if t_round < start_sec:
+                    continue
             points_xy = analyzer._to_points_xy(filtered.loc[[row.name]], x_col, y_col)
             if points_xy.size == 0:
                 continue
             pixels = analyzer._world_to_pixel(points_xy, meta, radar_size)
             for x_val, y_val in pixels.tolist():
                 points.append((float(x_val), float(y_val), 1.0))
 
     return points
 
 
 @transaction.atomic
 def get_or_build_heatmap(
     profile_id: int,
     map_name: str,
     metric: str,
     side: str,
     period: str,
     time_slice: str = "all",
     version: str = ANALYTICS_VERSION,
     resolution: int = 64,
     *,
     force_rebuild: bool = False,
+    render_options: dict[str, float | None] | None = None,
 ) -> HeatmapAggregate:
+    map_name = normalize_map_name(map_name)
+    metric = normalize_metric(metric)
+    side = normalize_side(side)
+    period = normalize_period(period)
+    time_slice = normalize_time_slice(time_slice)
+    version = normalize_version(version)
     aggregate = HeatmapAggregate.objects.filter(
         profile_id=profile_id,
         map_name=map_name,
         metric=metric,
         side=side,
         period=period,
         time_slice=time_slice,
         analytics_version=version,
         resolution=resolution,
     ).first()
 
     if aggregate and not force_rebuild:
-        return ensure_heatmap_image(aggregate)
+        return ensure_heatmap_image(aggregate, **(render_options or {}))
 
     profile = PlayerProfile.objects.get(id=profile_id)
     steamid64 = _profile_steamid64(profile)
     if not steamid64:
         raise ValueError("SteamID64 is missing on player profile")
 
     demos_dir = get_demos_dir(profile, map_name)
     points, radar_size = _collect_points_from_cache(demos_dir, steamid64, map_name, period, side, metric, time_slice)
     bounds = (0.0, 0.0, float(radar_size[0] or 1), float(radar_size[1] or 1))
     grid, max_value = build_heatmap_grid(points, resolution=resolution, bounds=bounds)
 
     aggregate, _ = HeatmapAggregate.objects.update_or_create(
         profile_id=profile_id,
         map_name=map_name,
         metric=metric,
         side=side,
         period=period,
         time_slice=time_slice,
         analytics_version=version,
         resolution=resolution,
         defaults={
             "grid": to_jsonable(grid),
             "max_value": to_jsonable(max_value),
             "updated_at": timezone.now(),
         },
     )
 
-    return ensure_heatmap_image(aggregate, force=True)
+    return ensure_heatmap_image(aggregate, force=True, **(render_options or {}))
diff --git a/faceit_analytics/services/pipeline.py b/faceit_analytics/services/pipeline.py
index 9f10cc44c2b42bfa14673060e27c5202a7e1c2b8..a60b3a1d8f3f633dc92fe23bcd4c8c5968a50614 100644
--- a/faceit_analytics/services/pipeline.py
+++ b/faceit_analytics/services/pipeline.py
@@ -1,36 +1,37 @@
 import traceback
 
 from django.core.cache import cache
 from django.utils import timezone
 
 from faceit_analytics.cache_keys import HeatmapKeyParts, heatmap_image_url_key, heatmap_meta_key, profile_metrics_key
 from faceit_analytics.constants import ANALYTICS_VERSION
 from faceit_analytics.models import AnalyticsAggregate, HeatmapAggregate, ProcessingJob
 from faceit_analytics.services.aggregates import build_metrics, enrich_metrics_with_role_features
 from faceit_analytics.services.demo_events import get_or_build_demo_features
 from faceit_analytics.services.heatmaps import DEFAULT_MAPS, get_or_build_heatmap
+from faceit_analytics.services.paths import ensure_profile_dirs
 from users.faceit import fetch_faceit_profile_details
 from users.models import PlayerProfile
 
 
 def sync_faceit_profile(profile: PlayerProfile) -> None:
     nickname = profile.user.faceit_nickname
     if not nickname:
         return
 
     faceit_data = fetch_faceit_profile_details(nickname)
     if not faceit_data:
         return
 
     profile.faceit_player_id = faceit_data.get("player_id", profile.faceit_player_id)
     profile.country = faceit_data.get("country", profile.country)
     profile.level = faceit_data.get("skill_level", profile.level)
     profile.elo = faceit_data.get("faceit_elo", profile.elo)
     profile.skill_level = faceit_data.get("skill_level", profile.skill_level)
     profile.faceit_url = faceit_data.get("faceit_url", profile.faceit_url)
     profile.avatar = faceit_data.get("avatar", profile.avatar)
     profile.steam_id = (
         faceit_data.get("steam_id_64")
         or faceit_data.get("game_player_id")
         or profile.steam_id
     )
@@ -121,50 +122,51 @@ def _invalidate_cache(profile_id: int, period: str, resolution: int, map_name: s
         pass
 
 
 def run_full_pipeline(
     profile_id: int,
     job_id: int,
     period: str = "last_20",
     map_name: str = "de_mirage",
     resolution: int = 64,
     force_rebuild: bool = False,
     force_heatmaps: bool = False,
     force_demo_features: bool = False,
 ) -> None:
     job = ProcessingJob.objects.select_related("profile").get(id=job_id)
     _update_job(
         job,
         status=ProcessingJob.STATUS_RUNNING,
         progress=1,
         error="",
         started_at=job.started_at or timezone.now(),
         finished_at=None,
     )
 
     try:
         profile = job.profile
+        ensure_profile_dirs(profile)
         sync_faceit_profile(profile)
         _update_job(job, progress=10)
 
         aggregates = build_metrics(profile, period=period, analytics_version=ANALYTICS_VERSION, map_name=map_name)
         _update_job(job, progress=20)
 
         demo_features = get_or_build_demo_features(
             profile,
             period=period,
             map_name=map_name,
             analytics_version=ANALYTICS_VERSION,
             force_rebuild=force_demo_features or force_rebuild,
             progress_callback=lambda progress: _update_job(job, progress=progress),
             progress_start=20,
             progress_end=40,
         )
         if aggregates:
             enrich_metrics_with_role_features(aggregates[0], profile, period, demo_features=demo_features)
         _update_job(job, progress=60)
 
         build_heatmaps(
             job,
             profile,
             period=period,
             map_name=map_name,
diff --git a/faceit_analytics/tests/test_api_heatmaps.py b/faceit_analytics/tests/test_api_heatmaps.py
index 6ba1347df29b799833403c974a49e5b11a0dd0dd..af313b5e9c8e4eb00433c5ec0ba2a00f99950394 100644
--- a/faceit_analytics/tests/test_api_heatmaps.py
+++ b/faceit_analytics/tests/test_api_heatmaps.py
@@ -17,51 +17,51 @@ from users.models import PlayerProfile  # noqa: E402
 class HeatmapMeApiTests(TestCase):
     def setUp(self):
         User = get_user_model()
         self.user1 = User.objects.create_user(
             username="user1",
             email="user1@example.com",
             password="pass",
             user_type="player",
         )
         self.user2 = User.objects.create_user(
             username="user2",
             email="user2@example.com",
             password="pass",
             user_type="player",
         )
         self.profile1 = PlayerProfile.objects.create(user=self.user1, steam_id="76561198000000001")
         self.profile2 = PlayerProfile.objects.create(user=self.user2, steam_id="76561198000000002")
         self.client = Client()
 
     def _create_heatmap(self, profile_id: int, tmp_dir: str, time_slice: str = "0-15") -> HeatmapAggregate:
         grid = [[0.0, 1.0], [0.0, 0.0]]
         aggregate = HeatmapAggregate.objects.create(
             profile_id=profile_id,
             map_name="de_mirage",
             metric=HeatmapAggregate.METRIC_KILLS,
-            side="ALL",
+            side="all",
             period="last_20",
             time_slice=time_slice,
             analytics_version="v2",
             resolution=64,
             grid=grid,
             max_value=1.0,
         )
         with override_settings(MEDIA_ROOT=tmp_dir, MEDIA_URL="/media/"):
             aggregate = ensure_heatmap_image(aggregate, force=True)
         return aggregate
 
     def test_heatmap_me_requires_login(self):
         response = self.client.get("/api/heatmaps/me?map=de_mirage")
         assert response.status_code == 302
 
     def test_heatmap_me_uses_logged_in_profile(self):
         with tempfile.TemporaryDirectory() as tmp_dir:
             aggregate1 = self._create_heatmap(self.profile1.id, tmp_dir)
             aggregate2 = self._create_heatmap(self.profile2.id, tmp_dir)
 
             assert self.client.login(username="user1", password="pass") is True
             with override_settings(MEDIA_ROOT=tmp_dir, MEDIA_URL="/media/"):
                 response = self.client.get(
                     "/api/heatmaps/me?map=de_mirage&metric=kills&side=ALL&period=last_20&slice=0-15&v=v2&res=64"
                 )
diff --git a/faceit_analytics/tests/test_demo_events.py b/faceit_analytics/tests/test_demo_events.py
index bc9aae37ca6a7167dd9e811a94d6b01d0dc54a6c..38770ff1785e09678b00d3cd017067e994bfc0b5 100644
--- a/faceit_analytics/tests/test_demo_events.py
+++ b/faceit_analytics/tests/test_demo_events.py
@@ -144,29 +144,29 @@ def test_name_fallback_matching():
 
     _, _, debug = demo_events.aggregate_player_features([parsed], str(target_id))
     assert debug["player_kills"] == 1
     assert debug["player_deaths"] == 1
     assert debug["target_name"] == "Player"
 
 
 def test_awareness_before_death_basic():
     events = [
         {"type": "damage", "round": 1, "time": 10.0},
         {"type": "death", "round": 1, "time": 12.0},
         {"type": "death", "round": 1, "time": 40.0},
     ]
     result = demo_events.compute_awareness_before_death(events)
     assert result["aware_deaths"] == 1
     assert result["total_deaths"] == 2
     assert result["awareness_before_death_rate"] == 50.0
 
 
 def test_multikill_basic_case():
     events = [
         {"type": "kill", "round": 1, "time": 5.0, "attacker_place": "A Site"},
         {"type": "kill", "round": 1, "time": 12.0, "attacker_place": "A Site"},
         {"type": "kill", "round": 2, "time": 50.0, "attacker_place": "B Site"},
     ]
-    result = demo_events.compute_multikill_metrics(events)
+    result = demo_events.compute_multikill_metrics(events, "de_mirage")
     assert result["multikill_events"] == 1
     assert result["by_timing"]["early"] == 1
-    assert result["by_zone"]["A Site"] == 1
+    assert result["by_zone"]["A"] == 1
diff --git a/faceit_analytics/tests/test_demo_paths.py b/faceit_analytics/tests/test_demo_paths.py
new file mode 100644
index 0000000000000000000000000000000000000000..d671c786cc3eadd3346d9c9a91162f12b22e979e
--- /dev/null
+++ b/faceit_analytics/tests/test_demo_paths.py
@@ -0,0 +1,32 @@
+from django.contrib.auth import get_user_model
+from django.test import override_settings
+
+from faceit_analytics.services.demo_events import discover_demo_files
+from users.models import PlayerProfile
+from uuid import uuid4
+
+
+def test_discover_demo_files_uses_media_local_demos_only(tmp_path):
+    media_root = tmp_path / "media"
+    other_root = tmp_path / "other_demos"
+    other_root.mkdir(parents=True, exist_ok=True)
+    other_demo = other_root / "outside.dem"
+    other_demo.write_bytes(b"outside")
+
+    with override_settings(MEDIA_ROOT=media_root):
+        unique_suffix = uuid4().hex
+        user = get_user_model().objects.create_user(
+            username=f"demo-user-{unique_suffix}",
+            email=f"demo-user-{unique_suffix}@example.com",
+            password="pass",
+            user_type="player",
+        )
+        profile = PlayerProfile.objects.create(user=user, steam_id="76561198000000088")
+        demo_dir = media_root / "local_demos" / profile.steam_id / "de_mirage"
+        demo_dir.mkdir(parents=True, exist_ok=True)
+        local_demo = demo_dir / "local.dem"
+        local_demo.write_bytes(b"local")
+
+        demos = discover_demo_files(profile, "last_20", "de_mirage", demos_dir=other_root)
+        assert local_demo in demos
+        assert other_demo not in demos
diff --git a/faceit_analytics/tests/test_heatmap_cache.py b/faceit_analytics/tests/test_heatmap_cache.py
new file mode 100644
index 0000000000000000000000000000000000000000..45518a59ba514b16095b72fad2b37c9fe84ff40d
--- /dev/null
+++ b/faceit_analytics/tests/test_heatmap_cache.py
@@ -0,0 +1,129 @@
+import numpy as np
+from PIL import Image
+from django.test import override_settings
+from unittest import mock
+
+from faceit_analytics import analyzer
+from faceit_analytics.services.heatmaps import _collect_points_from_cache, build_heatmap_grid
+
+
+def _write_demo(tmp_path, steamid, map_name, demo_name="match.dem"):
+    demos_dir = tmp_path / "local_demos" / steamid / map_name
+    demos_dir.mkdir(parents=True, exist_ok=True)
+    demo_path = demos_dir / demo_name
+    demo_path.write_bytes(b"demo")
+    return demo_path, demos_dir
+
+
+def _write_cache(tmp_path, steamid, map_name, demo_path, data, radar_name, radar_size):
+    cache_name = analyzer._demo_cache_hash(demo_path, radar_name, radar_size)
+    cache_dir = tmp_path / "heatmaps_cache" / steamid / map_name
+    cache_dir.mkdir(parents=True, exist_ok=True)
+    cache_path = cache_dir / f"{cache_name}.npz"
+    np.savez_compressed(cache_path, **data)
+    return radar_size
+
+
+def test_slice_filters_points_changes_grid(tmp_path):
+    steamid = "76561198000000099"
+    map_name = "de_mirage"
+    demo_path, demos_dir = _write_demo(tmp_path, steamid, map_name)
+    radar_name = "fake_radar"
+    radar_size = (100, 100)
+    radar_image = Image.new("RGBA", radar_size)
+
+    radar_size = _write_cache(
+        tmp_path,
+        steamid,
+        map_name,
+        demo_path,
+        {
+            "presence_all_px": np.array([[10.0, 10.0]], dtype=np.float32),
+            "presence_all_pxt": np.array([[10.0, 10.0, 10.0], [50.0, 50.0, 20.0]], dtype=np.float32),
+        },
+        radar_name,
+        radar_size,
+    )
+
+    with override_settings(MEDIA_ROOT=tmp_path), mock.patch(
+        "faceit_analytics.analyzer.load_radar_and_meta",
+        return_value=(radar_image, {}, radar_name),
+    ):
+        points_early, _size = _collect_points_from_cache(
+            demos_dir,
+            steamid,
+            map_name,
+            "last_20",
+            "all",
+            "presence",
+            "0-15",
+        )
+        points_late, _size = _collect_points_from_cache(
+            demos_dir,
+            steamid,
+            map_name,
+            "last_20",
+            "all",
+            "presence",
+            "15-30",
+        )
+
+    bounds = (0.0, 0.0, float(radar_size[0]), float(radar_size[1]))
+    grid_early, _ = build_heatmap_grid(points_early, resolution=8, bounds=bounds)
+    grid_late, _ = build_heatmap_grid(points_late, resolution=8, bounds=bounds)
+
+    assert points_early != points_late
+    assert not np.array_equal(np.array(grid_early), np.array(grid_late))
+
+
+def test_heatmap_ct_t_not_equal_when_data_diff(tmp_path):
+    steamid = "76561198000000100"
+    map_name = "de_mirage"
+    demo_path, demos_dir = _write_demo(tmp_path, steamid, map_name)
+    radar_name = "fake_radar"
+    radar_size = (100, 100)
+    radar_image = Image.new("RGBA", radar_size)
+    radar_size = _write_cache(
+        tmp_path,
+        steamid,
+        map_name,
+        demo_path,
+        {
+            "presence_ct_px": np.array([[5.0, 5.0]], dtype=np.float32),
+            "presence_t_px": np.array([[90.0, 90.0]], dtype=np.float32),
+            "presence_ct_pxt": np.array([[5.0, 5.0, 10.0]], dtype=np.float32),
+            "presence_t_pxt": np.array([[90.0, 90.0, 10.0]], dtype=np.float32),
+        },
+        radar_name,
+        radar_size,
+    )
+
+    with override_settings(MEDIA_ROOT=tmp_path), mock.patch(
+        "faceit_analytics.analyzer.load_radar_and_meta",
+        return_value=(radar_image, {}, radar_name),
+    ):
+        points_ct, _size = _collect_points_from_cache(
+            demos_dir,
+            steamid,
+            map_name,
+            "last_20",
+            "ct",
+            "presence",
+            "all",
+        )
+        points_t, _size = _collect_points_from_cache(
+            demos_dir,
+            steamid,
+            map_name,
+            "last_20",
+            "t",
+            "presence",
+            "all",
+        )
+
+    bounds = (0.0, 0.0, float(radar_size[0]), float(radar_size[1]))
+    grid_ct, _ = build_heatmap_grid(points_ct, resolution=8, bounds=bounds)
+    grid_t, _ = build_heatmap_grid(points_t, resolution=8, bounds=bounds)
+
+    assert points_ct != points_t
+    assert not np.array_equal(np.array(grid_ct), np.array(grid_t))
diff --git a/faceit_analytics/tests/test_heatmap_normalization.py b/faceit_analytics/tests/test_heatmap_normalization.py
new file mode 100644
index 0000000000000000000000000000000000000000..9898a826b6d9b785351ad8b4e03b32e6cbb2942b
--- /dev/null
+++ b/faceit_analytics/tests/test_heatmap_normalization.py
@@ -0,0 +1,9 @@
+from faceit_analytics.services.heatmaps import normalize_side
+
+
+def test_side_normalization_ct_t_all():
+    assert normalize_side("CT") == "ct"
+    assert normalize_side("T") == "t"
+    assert normalize_side("ALL") == "all"
+    assert normalize_side("ct") == "ct"
+    assert normalize_side("unknown") == "all"
diff --git a/faceit_analytics/tests/test_heatmaps.py b/faceit_analytics/tests/test_heatmaps.py
index f79d2b634689b897fab43feae270795d82184cdb..06081f337e5c5e25ff67480a550af2d217f28730 100644
--- a/faceit_analytics/tests/test_heatmaps.py
+++ b/faceit_analytics/tests/test_heatmaps.py
@@ -39,183 +39,211 @@ def test_render_heatmap_no_blur_keeps_hotspot_visible():
         [0.0, 0.0, 0.0, 0.0],
         [0.0, 5.0, 0.0, 0.0],
         [0.0, 0.0, 0.0, 0.0],
     ]
     with override_settings(
         HEATMAP_BLUR_SIGMA_GRID=0,
         HEATMAP_BLUR_SIGMA_OUTPUT=0,
         HEATMAP_ALPHA=0.6,
         HEATMAP_GAMMA=0.85,
         HEATMAP_NORM_PERCENTILE=99,
     ):
         image = render_heatmap_image(grid, output_size=64, blur_sigma_grid=0)
     pixels = np.array(image)
     alpha = pixels[:, :, 3]
     assert alpha.max() > 120
     assert np.percentile(alpha, 90) < 200
     assert pixels[:, :, :3].max() > 40
 
 
 def test_metric_affects_filename_or_url():
     grid = [[0.0, 1.0], [0.0, 0.0]]
     kills = HeatmapAggregate(
         profile_id=1,
         map_name="de_mirage",
         metric=HeatmapAggregate.METRIC_KILLS,
-        side="ALL",
+        side="all",
         period="last_20",
         time_slice="all",
         analytics_version="v2",
         resolution=64,
         grid=grid,
         max_value=1.0,
     )
     deaths = HeatmapAggregate(
         profile_id=1,
         map_name="de_mirage",
         metric=HeatmapAggregate.METRIC_DEATHS,
-        side="ALL",
+        side="all",
         period="last_20",
         time_slice="all",
         analytics_version="v2",
         resolution=64,
         grid=grid,
         max_value=1.0,
     )
     presence = HeatmapAggregate(
         profile_id=1,
         map_name="de_mirage",
         metric=HeatmapAggregate.METRIC_PRESENCE,
-        side="ALL",
+        side="all",
         period="last_20",
         time_slice="all",
         analytics_version="v2",
         resolution=64,
         grid=grid,
         max_value=1.0,
     )
     grid_array = np.array(grid, dtype=np.float32)
     kills_name = _build_heatmap_filename(kills, grid_array)
     deaths_name = _build_heatmap_filename(deaths, grid_array)
     presence_name = _build_heatmap_filename(presence, grid_array)
     assert kills_name != deaths_name
     assert kills_name != presence_name
     assert "kills" in kills_name
     assert "deaths" in deaths_name
     assert "presence" in presence_name
 
 
 def test_force_regenerates_version(tmp_path):
     grid = [[0.0, 1.0], [0.0, 0.0]]
     aggregate = HeatmapAggregate(
         profile_id=1,
         map_name="de_mirage",
         metric=HeatmapAggregate.METRIC_KILLS,
-        side="ALL",
+        side="all",
         period="last_20",
         time_slice="all",
         analytics_version="v2",
         resolution=64,
         grid=grid,
         max_value=1.0,
     )
     aggregate.save = lambda *args, **kwargs: None
 
     with override_settings(MEDIA_ROOT=str(tmp_path), MEDIA_URL="/media/"):
         first = ensure_heatmap_image(aggregate, force=True)
         first_name = first.image.name
         first_path = Path(tmp_path) / first_name
         first_version = int(first_path.stat().st_mtime)
         first_updated = first.updated_at
 
         second = ensure_heatmap_image(aggregate, force=True)
         second_name = second.image.name
         second_path = Path(tmp_path) / second_name
         second_version = int(second_path.stat().st_mtime)
         second_updated = second.updated_at
 
     assert first_name != second_name or first_version != second_version
     assert second_updated >= first_updated
 
 
+def test_force_regenerates_and_deletes_old_file(tmp_path):
+    grid = [[0.0, 1.0], [0.0, 0.0]]
+    aggregate = HeatmapAggregate(
+        profile_id=1,
+        map_name="de_mirage",
+        metric=HeatmapAggregate.METRIC_KILLS,
+        side="all",
+        period="last_20",
+        time_slice="all",
+        analytics_version="v2",
+        resolution=64,
+        grid=grid,
+        max_value=1.0,
+    )
+    aggregate.save = lambda *args, **kwargs: None
+
+    with override_settings(MEDIA_ROOT=str(tmp_path), MEDIA_URL="/media/"):
+        first = ensure_heatmap_image(aggregate, force=True)
+        first_path = Path(tmp_path) / first.image.name
+        assert first_path.exists()
+
+        second = ensure_heatmap_image(aggregate, force=True)
+        second_path = Path(tmp_path) / second.image.name
+
+    assert second_path.exists()
+    assert not first_path.exists()
+
+
 def test_missing_file_regenerates_heatmap(tmp_path):
     grid = [[0.0, 1.0], [0.0, 0.0]]
     aggregate = HeatmapAggregate(
         profile_id=1,
         map_name="de_mirage",
         metric=HeatmapAggregate.METRIC_KILLS,
-        side="ALL",
+        side="all",
         period="last_20",
         time_slice="all",
         analytics_version="v2",
         resolution=64,
         grid=grid,
         max_value=1.0,
     )
     aggregate.save = lambda *args, **kwargs: None
 
     with override_settings(MEDIA_ROOT=str(tmp_path), MEDIA_URL="/media/"):
         aggregate = ensure_heatmap_image(aggregate, force=True)
         assert aggregate.image
         image_path = Path(tmp_path) / aggregate.image.name
         assert image_path.exists()
         image_path.unlink()
 
         aggregate = ensure_heatmap_image(aggregate)
         assert aggregate.image
         assert aggregate.image.storage.exists(aggregate.image.name)
 
 
 def test_heat_overlay_not_invisible():
     grid = [
         [0.0, 2.0, 0.0, 0.0],
         [0.0, 5.0, 3.0, 0.0],
         [0.0, 3.0, 6.0, 0.0],
         [0.0, 0.0, 1.0, 0.0],
     ]
     with override_settings(
         HEATMAP_OUTPUT_SIZE=64,
         HEATMAP_BLUR_SIGMA_GRID=0.6,
         HEATMAP_BLUR_SIGMA_OUTPUT=0.0,
         HEATMAP_GAMMA=0.6,
         HEATMAP_ALPHA=0.75,
         HEATMAP_NORM_PERCENTILE=99.5,
     ):
         image = render_heatmap_image(grid)
     pixels = np.array(image)
     alpha = pixels[:, :, 3]
     visible_ratio = (alpha > 10).sum() / alpha.size
     assert visible_ratio > 0.005
 
 
 def test_atomic_write_used(tmp_path):
     grid = [[0.0, 1.0], [0.0, 0.0]]
     aggregate = HeatmapAggregate(
         profile_id=1,
         map_name="de_mirage",
         metric=HeatmapAggregate.METRIC_KILLS,
-        side="ALL",
+        side="all",
         period="last_20",
         time_slice="all",
         analytics_version="v2",
         resolution=64,
         grid=grid,
         max_value=1.0,
     )
     aggregate.save = lambda *args, **kwargs: None
 
     with override_settings(MEDIA_ROOT=str(tmp_path), MEDIA_URL="/media/"):
         with mock.patch("faceit_analytics.services.heatmaps.os.replace", wraps=os.replace) as replace_mock:
             aggregate = ensure_heatmap_image(aggregate, force=True)
             assert replace_mock.called
 
         tmp_files = list(Path(tmp_path).rglob("*.tmp.*"))
         assert not tmp_files
         assert aggregate.image.storage.exists(aggregate.image.name)
 
 
 def test_metric_renders_different_palettes():
     grid = [
         [0.0, 0.0, 0.0, 0.0],
         [0.0, 3.0, 6.0, 0.0],
         [0.0, 2.0, 0.0, 0.0],
         [0.0, 0.0, 0.0, 0.0],
diff --git a/faceit_analytics/views.py b/faceit_analytics/views.py
index be0896d8f308ef1c7a0c9b0819e32151bdd292ef..91644684ce371f730d4cd146e360b869259bb5d8 100644
--- a/faceit_analytics/views.py
+++ b/faceit_analytics/views.py
@@ -1,45 +1,54 @@
 import json
 import time
 from pathlib import Path
 
 from django.conf import settings
 from django.contrib.auth.decorators import login_required
 from django.core.cache import cache
 from django.core.files.storage import default_storage
 from django.http import JsonResponse
 from django.shortcuts import get_object_or_404
 from django.views.decorators.http import require_GET, require_POST
 from requests import HTTPError
 
 from .cache_keys import DEFAULT_TTL_SECONDS, HeatmapKeyParts, heatmap_image_url_key, heatmap_meta_key
 from .constants import ANALYTICS_VERSION
 from .analyzer import build_heatmaps
 from .demo_fetch import get_demo_dem_path
 from .faceit_client import FaceitClient
 from .models import AnalyticsAggregate, HeatmapAggregate, ProcessingJob
-from .services.heatmaps import ensure_heatmap_image, get_or_build_heatmap, normalize_time_slice
+from .services.heatmaps import (
+    ensure_heatmap_image,
+    get_or_build_heatmap,
+    normalize_map_name,
+    normalize_metric,
+    normalize_period,
+    normalize_side,
+    normalize_time_slice,
+    normalize_version,
+)
 from .tasks import task_full_pipeline
 from .utils import to_jsonable
 from users.models import PlayerProfile
 
 
 def _with_cache_buster(url: str | None, version: int | None) -> str | None:
     if not url:
         return url
     version = int(version if version is not None else time.time())
     separator = "&" if "?" in url else "?"
     return f"{url}{separator}v={version}"
 
 
 @require_GET
 def faceit_heatmaps(request):
     """
     GET /api/faceit/heatmaps?nickname=NAME
     Возвращает JSON + ссылки на PNG в MEDIA.
     """
     nickname = request.GET.get("nickname", "").strip()
     if not nickname:
         return JsonResponse({"error": "nickname is required"}, status=400)
 
     client = FaceitClient(api_key=getattr(settings, "FACEIT_API_KEY", None))
 
@@ -238,83 +247,91 @@ def analytics_job_status(request, job_id: int):
         return JsonResponse({"error": "forbidden"}, status=403)
 
     status_map = {
         ProcessingJob.STATUS_STARTED: ProcessingJob.STATUS_RUNNING,
         ProcessingJob.STATUS_PROCESSING: ProcessingJob.STATUS_RUNNING,
         ProcessingJob.STATUS_DONE: ProcessingJob.STATUS_SUCCESS,
     }
     payload = {
         "status": status_map.get(job.status, job.status),
         "progress": job.progress,
     }
     if job.error:
         payload["error"] = job.error
     if job.started_at:
         payload["started_at"] = job.started_at.isoformat()
     if job.finished_at:
         payload["finished_at"] = job.finished_at.isoformat()
     return JsonResponse(payload)
 
 
 def _get_request_profile(request) -> PlayerProfile:
     return get_object_or_404(PlayerProfile, user=request.user)
 
 
 def _heatmap_response(request, profile: PlayerProfile) -> JsonResponse:
-    period = request.GET.get("period", "last_20").strip() or "last_20"
-    map_name = request.GET.get("map", "de_mirage").strip() or "de_mirage"
-    side = request.GET.get("side", AnalyticsAggregate.SIDE_ALL).strip().upper() or AnalyticsAggregate.SIDE_ALL
-    kind = (request.GET.get("kind") or request.GET.get("metric") or HeatmapAggregate.METRIC_KILLS).strip().lower()
-    if kind not in {
-        HeatmapAggregate.METRIC_KILLS,
-        HeatmapAggregate.METRIC_DEATHS,
-        HeatmapAggregate.METRIC_PRESENCE,
-    }:
-        kind = HeatmapAggregate.METRIC_KILLS
-    if side not in {AnalyticsAggregate.SIDE_ALL, AnalyticsAggregate.SIDE_CT, AnalyticsAggregate.SIDE_T}:
-        side = AnalyticsAggregate.SIDE_ALL
-    version = request.GET.get("v", ANALYTICS_VERSION).strip() or ANALYTICS_VERSION
+    period = normalize_period(request.GET.get("period", "last_20"))
+    map_name = normalize_map_name(request.GET.get("map", "de_mirage"))
+    side = normalize_side(request.GET.get("side", AnalyticsAggregate.SIDE_ALL))
+    kind = normalize_metric(request.GET.get("kind") or request.GET.get("metric") or HeatmapAggregate.METRIC_KILLS)
+    version = normalize_version(request.GET.get("v", ANALYTICS_VERSION))
     time_slice = normalize_time_slice(request.GET.get("slice") or request.GET.get("t"))
     try:
         resolution = int(request.GET.get("res", 64))
     except (TypeError, ValueError):
         resolution = 64
     if resolution not in {64, 128, 256}:
         resolution = 64
+    render_options: dict[str, float] = {}
+    for key, target in (
+        ("blur", "blur"),
+        ("gamma", "gamma"),
+        ("alpha", "alpha"),
+        ("clip", "clip_pct"),
+    ):
+        raw = request.GET.get(key)
+        if raw is None or raw == "":
+            continue
+        try:
+            render_options[target] = float(raw)
+        except (TypeError, ValueError):
+            continue
 
     parts = HeatmapKeyParts(
         profile_id=profile.id,
         map_name=map_name,
         metric=kind,
         side=side,
         period=period,
         time_slice=time_slice,
         version=version,
         resolution=resolution,
     )
     cache_key = heatmap_meta_key(parts)
     force_regen = request.GET.get("force") == "1"
+    if render_options:
+        force_regen = True
     if not force_regen:
         try:
             cached = cache.get(cache_key)
         except Exception:
             cached = None
         if cached:
             image_url = cached.get("image_url")
             if image_url:
                 base_url = settings.MEDIA_URL or ""
                 path = image_url.split("?", 1)[0]
                 if base_url and path.startswith(base_url):
                     storage_path = path[len(base_url) :]
                     if not default_storage.exists(storage_path):
                         cached = None
             if cached:
                 return JsonResponse(to_jsonable(cached))
 
     aggregate = HeatmapAggregate.objects.filter(
         profile=profile,
         period=period,
         map_name=map_name,
         metric=kind,
         side=side,
         analytics_version=version,
         resolution=resolution,
@@ -324,64 +341,67 @@ def _heatmap_response(request, profile: PlayerProfile) -> JsonResponse:
     response = {
         "status": "missing",
         "image_url": None,
         "updated_at": None,
         "resolution": resolution,
         "version": None,
         "metric": kind,
         "kind": kind,
         "side": side,
         "map": map_name,
         "period": period,
         "slice": time_slice,
         "res": resolution,
         "meta": {
             "map": map_name,
             "side": side,
             "period": period,
             "slice": time_slice,
             "kind": kind,
             "metric": kind,
             "resolution": resolution,
             "version": version,
         },
     }
 
+    render_options_payload = render_options or None
+
     if force_regen:
         aggregate = get_or_build_heatmap(
             profile_id=profile.id,
             map_name=map_name,
             metric=kind,
             side=side,
             period=period,
             time_slice=time_slice,
             version=version,
             resolution=resolution,
             force_rebuild=True,
+            render_options=render_options_payload,
         )
     elif aggregate:
-        aggregate = ensure_heatmap_image(aggregate, force=False)
+        aggregate = ensure_heatmap_image(aggregate, force=False, **(render_options_payload or {}))
 
     if aggregate and aggregate.image:
         updated_at = aggregate.updated_at.isoformat() if aggregate.updated_at else None
         try:
             file_version = int(Path(aggregate.image.path).stat().st_mtime)
         except Exception:
             file_version = int(time.time())
         image_url = _with_cache_buster(aggregate.image.url, file_version)
         response.update(
             {
                 "status": "ready",
                 "image_url": image_url,
                 "updated_at": updated_at,
                 "version": file_version,
             }
         )
         response = to_jsonable(response)
         try:
             cache.set(cache_key, response, DEFAULT_TTL_SECONDS)
             cache.set(heatmap_image_url_key(parts), image_url, DEFAULT_TTL_SECONDS)
         except Exception:
             pass
         return JsonResponse(response)
 
     job = (
diff --git a/users/templates/users/profile.html b/users/templates/users/profile.html
index a8098bb2aeec6795b4118a9e5742e63cda2bad64..2f6ad2bce29bc327ead71e9411cf412d28f48975 100644
--- a/users/templates/users/profile.html
+++ b/users/templates/users/profile.html
@@ -175,59 +175,59 @@
                                     <span>Nuke</span>
                                     <strong>{{ player_profile.get_nuke_ct_position_display }}</strong>
                                 </div>
                                 <div class="role-item">
                                     <span>Ancient</span>
                                     <strong>{{ player_profile.get_ancient_ct_position_display }}</strong>
                                 </div>
                                 <div class="role-item">
                                     <span>Inferno</span>
                                     <strong>{{ player_profile.get_inferno_ct_position_display }}</strong>
                                 </div>
                                 <div class="role-item">
                                     <span>Overpass</span>
                                     <strong>{{ player_profile.get_overpass_ct_position_display }}</strong>
                                 </div>
                             </div>
                         </div>
                         <div class="roles-column">
                             <h4>T</h4>
                             <div class="roles-list">
                                 <div class="role-item">
                                     <span>Роль</span>
                                     <strong>{{ player_profile.get_t_role_display }}</strong>
                                 </div>
                                 <div class="role-item">
-                                    <span>IGL</span>
+                                    <span>Игровой лидер</span>
                                     {% if player_profile.is_igl %}
                                         <strong class="status-active">Да</strong>
                                     {% else %}
                                         <strong class="status-inactive">Нет</strong>
                                     {% endif %}
                                 </div>
                                 <div class="role-item">
-                                    <span>AWP</span>
+                                    <span>Снайпер</span>
                                     {% if player_profile.can_awp %}
                                         <strong class="status-active">Да</strong>
                                     {% else %}
                                         <strong class="status-inactive">Нет</strong>
                                     {% endif %}
                                 </div>
                             </div>
                         </div>
                     </div>
                     {% if player_profile.description %}
                     <div class="role-description">
                         {{ player_profile.description|linebreaks }}
                     </div>
                     {% endif %}
                 </div>
 
                 <div id="analytics-root"
                      class="analytics-card"
                      data-profile-id="{{ player_profile.id }}"
                      data-job-id="{% if analytics_job %}{{ analytics_job.id }}{% endif %}"
                      data-job-status="{% if analytics_job %}{{ analytics_job.status }}{% endif %}"
                      data-period="{{ analytics_period|default:'last_20' }}"
                      data-can-trigger="{% if can_trigger_analytics %}1{% else %}0{% endif %}">
                     <div class="analytics-header">
                         <h3>Аналитика</h3>
@@ -266,416 +266,436 @@
                                 Аналитика в обработке… {{ analytics_job.progress }}%
                             {% endif %}
                         {% elif analytics_ready %}
                             Аналитика готова.
                         {% else %}
                             Аналитика ещё не готова.
                         {% endif %}
                     </div>
                     {% if analytics_metrics.demo_features_approx %}
                         <div class="analytics-meta">
                             Демо не найдено — роль/utility/timing будут приближенно.
                         </div>
                     {% endif %}
                     {% if analytics_job and analytics_job.status == "FAILED" and analytics_job.error %}
                         <pre class="analytics-error">{{ analytics_job.error|truncatechars:220 }}</pre>
                     {% endif %}
                     {% if analytics_aggregates %}
                         <div class="analytics-metrics">
                             {% for key, value in analytics_simple_metrics.items %}
                                 <div class="analytics-metric">
                                     <span class="metric-label">{{ key }}</span>
                                     <strong class="metric-value">{{ value }}</strong>
                                 </div>
                             {% empty %}
                                 <div class="analytics-metric">
-                                    <span class="metric-label">Metrics</span>
+                                    <span class="metric-label">Метрики</span>
                                     <strong class="metric-value">Нет данных</strong>
                                 </div>
                             {% endfor %}
                         </div>
                         {% if analytics_metrics.kda %}
                             <div class="analytics-metrics analytics-metrics--kda">
                                 <div class="analytics-metric">
-                                    <span class="metric-label">Kills</span>
+                                    <span class="metric-label">Убийства</span>
                                     <strong class="metric-value">{{ analytics_metrics.kda.kills }}</strong>
                                 </div>
                                 <div class="analytics-metric">
-                                    <span class="metric-label">Deaths</span>
+                                    <span class="metric-label">Смерти</span>
                                     <strong class="metric-value">{{ analytics_metrics.kda.deaths }}</strong>
                                 </div>
                                 <div class="analytics-metric">
-                                    <span class="metric-label">Assists</span>
+                                    <span class="metric-label">Ассисты</span>
                                     <strong class="metric-value">{{ analytics_metrics.kda.assists }}</strong>
                                 </div>
                                 <div class="analytics-metric">
                                     <span class="metric-label">KDA</span>
                                     <strong class="metric-value">
                                         {% if analytics_metrics.kda.kda_ratio != None %}
                                             {{ analytics_metrics.kda.kda_ratio|floatformat:2 }}
                                         {% else %}
                                             —
                                         {% endif %}
                                     </strong>
                                 </div>
                             </div>
                         {% endif %}
                     {% endif %}
                 </div>
 
                 <div class="analytics-card role-fingerprint-card">
                     <div class="analytics-header">
-                        <h3>Role fingerprint</h3>
+                        <h3>Ролевой профиль</h3>
                     </div>
                     {% if analytics_metrics.role_fingerprint %}
                         {% if analytics_metrics.role_fingerprint.debug %}
                             {% if analytics_metrics.role_fingerprint.debug.demos_count == 0 %}
-                                <div class="analytics-empty">Upload demos to enable advanced metrics.</div>
+                                <div class="analytics-empty">Загрузите демки, чтобы включить расширенные метрики.</div>
                             {% elif analytics_metrics.role_fingerprint.debug.rounds_count < analytics_metrics.role_fingerprint.debug.min_rounds_required %}
-                                <div class="analytics-empty">Not enough rounds yet.</div>
+                                <div class="analytics-empty">Недостаточно раундов.</div>
                             {% endif %}
                         {% endif %}
                         <div class="role-tags">
                             {% for tag in analytics_metrics.role_fingerprint.tags %}
                                 <span class="role-chip">{{ tag }}</span>
                             {% empty %}
-                                <span class="role-chip role-chip--empty">Not enough data</span>
+                                <span class="role-chip role-chip--empty">Недостаточно данных</span>
                             {% endfor %}
                             {% if analytics_metrics.role_fingerprint.approx %}
-                                <span class="role-chip role-chip--approx">approx</span>
+                                <span class="role-chip role-chip--approx">приблизительно</span>
                             {% endif %}
                         </div>
                         <div class="role-summary">
                             {{ analytics_metrics.role_fingerprint.summary }}
                         </div>
                         <div class="role-metrics-grid">
                             <div class="role-metric">
-                                <span>First duel / round</span>
+                                <span>Первые дуэли / раунд</span>
                                 <strong>
                                     {% if analytics_metrics.role_fingerprint.metrics.first_duel_attempts_per_round.value != None %}
                                         {{ analytics_metrics.role_fingerprint.metrics.first_duel_attempts_per_round.value|floatformat:2 }}
                                     {% else %}
-                                        not enough data
+                                        недостаточно данных
                                     {% endif %}
                                 </strong>
                             </div>
                             <div class="role-metric">
-                                <span>First duel success</span>
+                                <span>Успех первых дуэлей</span>
                                 <strong>
                                     {% if analytics_metrics.role_fingerprint.metrics.first_duel_success_rate.value != None %}
                                         {{ analytics_metrics.role_fingerprint.metrics.first_duel_success_rate.value|floatformat:2 }}
                                     {% else %}
-                                        not enough data
+                                        недостаточно данных
                                     {% endif %}
                                 </strong>
                             </div>
                             <div class="role-metric">
-                                <span>Trade kill rate</span>
+                                <span>Доля разменов</span>
                                 <strong>
                                     {% if analytics_metrics.role_fingerprint.metrics.trade_kill_rate.value != None %}
                                         {{ analytics_metrics.role_fingerprint.metrics.trade_kill_rate.value|floatformat:2 }}
                                     {% else %}
-                                        not enough data
+                                        недостаточно данных
                                     {% endif %}
                                 </strong>
                             </div>
                             <div class="role-metric">
-                                <span>Traded death rate</span>
+                                <span>Доля размененных смертей</span>
                                 <strong>
                                     {% if analytics_metrics.role_fingerprint.metrics.traded_death_rate.value != None %}
                                         {{ analytics_metrics.role_fingerprint.metrics.traded_death_rate.value|floatformat:2 }}
                                     {% else %}
-                                        not enough data
+                                        недостаточно данных
                                     {% endif %}
                                 </strong>
                             </div>
                             <div class="role-metric">
-                                <span>Clutch win rate</span>
+                                <span>Успех клатчей</span>
                                 <strong>
                                     {% if analytics_metrics.role_fingerprint.metrics.clutch_win_rate.value != None %}
                                         {{ analytics_metrics.role_fingerprint.metrics.clutch_win_rate.value|floatformat:2 }}
                                     {% else %}
-                                        not enough data
+                                        недостаточно данных
                                     {% endif %}
                                 </strong>
                             </div>
                             <div class="role-metric">
-                                <span>Flash assists / round</span>
+                                <span>Флеш-ассисты / раунд</span>
                                 <strong>
                                     {% if analytics_metrics.role_fingerprint.metrics.flash_assists_per_round.value != None %}
                                         {{ analytics_metrics.role_fingerprint.metrics.flash_assists_per_round.value|floatformat:2 }}
                                     {% else %}
-                                        not enough data
+                                        недостаточно данных
                                     {% endif %}
                                 </strong>
                             </div>
                         </div>
                     {% else %}
-                        <div class="analytics-empty">Not enough data</div>
+                        <div class="analytics-empty">Недостаточно данных</div>
                     {% endif %}
                 </div>
 
                 <div class="analytics-card playstyle-card">
                     <div class="analytics-header">
-                        <h3>Playstyle archetype</h3>
+                        <h3>Архетип игрока</h3>
                     </div>
                     {% if analytics_metrics.playstyle %}
                         <div class="playstyle-label">
-                            <strong>{{ analytics_metrics.playstyle.label }}</strong>
+                            <strong>{{ analytics_metrics.playstyle.label_ru|default:analytics_metrics.playstyle.label }}</strong>
                             {% if analytics_metrics.playstyle.approx %}
-                                <span class="role-chip role-chip--approx">approx</span>
+                                <span class="role-chip role-chip--approx">приблизительно</span>
                             {% endif %}
                         </div>
+                        <div class="analytics-meta">
+                            {{ analytics_metrics.playstyle.explanation_ru|default:"Недостаточно данных." }}
+                        </div>
                         <ul class="playstyle-reasons">
-                            {% for reason in analytics_metrics.playstyle.reasons %}
+                            {% for reason in analytics_metrics.playstyle.reasons_ru %}
                                 <li>{{ reason }}</li>
                             {% empty %}
-                                <li>Not enough data for reasons.</li>
+                                <li>Недостаточно данных.</li>
                             {% endfor %}
                         </ul>
+                        <div class="analytics-meta">
+                            <strong>Выходы с тиммейтом / соло:</strong>
+                            {% if analytics_metrics.playstyle.entry_split.with_teammate != None and analytics_metrics.playstyle.entry_split.solo != None %}
+                                {{ analytics_metrics.playstyle.entry_split.with_teammate|floatformat:0 }}% /
+                                {{ analytics_metrics.playstyle.entry_split.solo|floatformat:0 }}%
+                            {% else %}
+                                недостаточно данных
+                            {% endif %}
+                        </div>
                     {% else %}
-                        <div class="analytics-empty">Not enough data</div>
+                        <div class="analytics-empty">Недостаточно данных</div>
                     {% endif %}
                 </div>
 
                 <div class="analytics-card utility-iq-card">
                     <div class="analytics-header">
-                        <h3>Utility IQ</h3>
+                        <h3>Интеллект утилити</h3>
                     </div>
                     {% if analytics_metrics.utility_iq %}
                         <div class="utility-score">
-                            <span>Score</span>
+                            <span>Оценка</span>
                             <strong>
                                 {% if analytics_metrics.utility_iq.score != None %}
                                     {{ analytics_metrics.utility_iq.score }}
                                 {% else %}
-                                    not enough data
+                                    недостаточно данных
                                 {% endif %}
                             </strong>
                             {% if analytics_metrics.utility_iq.approx %}
-                                <span class="role-chip role-chip--approx">approx</span>
+                                <span class="role-chip role-chip--approx">приблизительно</span>
                             {% endif %}
                         </div>
                         <div class="utility-breakdown">
                             <div>
-                                <span>Flash assists / round</span>
+                                <span>Флеш-ассисты / раунд</span>
                                 <strong>
                                     {% if analytics_metrics.utility_iq.breakdown.flash_assists_per_round.value != None %}
                                         {{ analytics_metrics.utility_iq.breakdown.flash_assists_per_round.value|floatformat:2 }}
                                     {% else %}
-                                        not enough data
+                                        недостаточно данных
                                     {% endif %}
                                 </strong>
                             </div>
                             <div>
-                                <span>Utility damage / round</span>
+                                <span>Урон утилити / раунд</span>
                                 <strong>
                                     {% if analytics_metrics.utility_iq.breakdown.utility_damage_per_round.value != None %}
                                         {{ analytics_metrics.utility_iq.breakdown.utility_damage_per_round.value|floatformat:2 }}
                                     {% else %}
-                                        not enough data
+                                        недостаточно данных
                                     {% endif %}
                                 </strong>
                             </div>
                             <div>
-                                <span>Friendly flash rate</span>
+                                <span>Флеши по своим</span>
                                 <strong>
                                     {% if analytics_metrics.utility_iq.breakdown.friendly_flash_rate.value != None %}
                                         {{ analytics_metrics.utility_iq.breakdown.friendly_flash_rate.value|floatformat:2 }}
                                     {% else %}
-                                        not enough data
+                                        недостаточно данных
                                     {% endif %}
                                 </strong>
                             </div>
                         </div>
                     {% else %}
-                        <div class="analytics-empty">Not enough data</div>
+                        <div class="analytics-empty">Недостаточно данных</div>
                     {% endif %}
                 </div>
 
                 <div class="analytics-card timing-control-card">
                     <div class="analytics-header">
-                        <h3>Timing control</h3>
+                        <h3>Контроль времени</h3>
                     </div>
                     {% if analytics_metrics.timing_slices %}
                         <table class="timing-table">
                             <thead>
                                 <tr>
-                                    <th>Window</th>
-                                    <th>Contacts</th>
+                                    <th>Окно</th>
+                                    <th>Контакты</th>
                                 </tr>
                             </thead>
                             <tbody>
                                 {% for bucket in analytics_metrics.timing_slices.buckets %}
                                     <tr>
                                         <td>{{ bucket.label }}</td>
                                         <td>
                                             {% if bucket.value != None %}
                                                 {{ bucket.value|floatformat:1 }}%
                                             {% else %}
-                                                not enough data
+                                                недостаточно данных
                                             {% endif %}
                                         </td>
                                     </tr>
                                 {% empty %}
                                     <tr>
-                                        <td colspan="2">not enough data</td>
+                                        <td colspan="2">недостаточно данных</td>
                                     </tr>
                                 {% endfor %}
                             </tbody>
                         </table>
                         {% if analytics_metrics.timing_slices.approx %}
-                            <div class="analytics-approx">approx</div>
+                            <div class="analytics-approx">приблизительно</div>
                         {% endif %}
                     {% else %}
-                        <div class="analytics-empty">Not enough data</div>
+                        <div class="analytics-empty">Недостаточно данных</div>
                     {% endif %}
                 </div>
 
                 <div class="analytics-card awareness-card">
                     <div class="analytics-header">
-                        <h3>Awareness before death</h3>
+                        <h3>Осведомлённость перед смертью</h3>
                     </div>
                     {% if analytics_metrics.awareness_before_death %}
                         <div class="analytics-metrics">
                             <div class="analytics-metric">
-                                <span class="metric-label">Awareness %</span>
+                                <span class="metric-label">Осведомлённость</span>
                                 <strong class="metric-value">
                                     {% if analytics_metrics.awareness_before_death.awareness_before_death_rate != None %}
                                         {{ analytics_metrics.awareness_before_death.awareness_before_death_rate|floatformat:2 }}%
                                     {% else %}
                                         —
                                     {% endif %}
                                 </strong>
                             </div>
                             <div class="analytics-metric">
-                                <span class="metric-label">Aware deaths</span>
+                                <span class="metric-label">Осознанные смерти</span>
                                 <strong class="metric-value">{{ analytics_metrics.awareness_before_death.aware_deaths }}</strong>
                             </div>
                             <div class="analytics-metric">
-                                <span class="metric-label">Total deaths</span>
+                                <span class="metric-label">Всего смертей</span>
                                 <strong class="metric-value">{{ analytics_metrics.awareness_before_death.total_deaths }}</strong>
                             </div>
                         </div>
                     {% else %}
-                        <div class="analytics-empty">Not enough data</div>
+                        <div class="analytics-empty">Недостаточно данных</div>
                     {% endif %}
                 </div>
 
                 <div class="analytics-card multikill-card">
                     <div class="analytics-header">
-                        <h3>Multi-kill breakdown</h3>
+                        <h3>Мультикиллы: выход на точку / удержание точки</h3>
                     </div>
                     {% if analytics_metrics.multikill %}
                         <div class="analytics-metrics">
                             <div class="analytics-metric">
-                                <span class="metric-label">Multi-kill rate</span>
+                                <span class="metric-label">Доля мультикиллов</span>
                                 <strong class="metric-value">
                                     {% if analytics_metrics.multikill.multikill_round_rate != None %}
                                         {{ analytics_metrics.multikill.multikill_round_rate|floatformat:2 }}%
                                     {% else %}
                                         —
                                     {% endif %}
                                 </strong>
                             </div>
                             <div class="analytics-metric">
-                                <span class="metric-label">Events</span>
+                                <span class="metric-label">События</span>
                                 <strong class="metric-value">{{ analytics_metrics.multikill.multikill_events }}</strong>
                             </div>
                             <div class="analytics-metric">
-                                <span class="metric-label">Early/late</span>
+                                <span class="metric-label">Рано / поздно</span>
                                 <strong class="metric-value">
                                     {{ analytics_metrics.multikill.by_timing.early|default:"0" }} /
                                     {{ analytics_metrics.multikill.by_timing.late|default:"0" }}
                                 </strong>
                             </div>
+                            <div class="analytics-metric">
+                                <span class="metric-label">Выход / удержание</span>
+                                <strong class="metric-value">
+                                    {{ analytics_metrics.multikill.by_phase.entry|default:"0" }} /
+                                    {{ analytics_metrics.multikill.by_phase.hold|default:"0" }}
+                                </strong>
+                            </div>
                         </div>
                     {% else %}
-                        <div class="analytics-empty">Not enough data</div>
+                        <div class="analytics-empty">Недостаточно данных</div>
                     {% endif %}
                 </div>
 
                 <div id="heatmaps-root"
                      class="heatmaps-card"
                      data-profile-id="{{ player_profile.id }}"
                      data-map="{{ analytics_map|default:'de_mirage' }}"
                      data-period="{{ analytics_period|default:'last_20' }}"
                      data-version="{{ analytics_version|default:'v2' }}"
                      data-resolution="256"
                      data-metric="kills"
                      data-slice="{{ heatmap_default_slice|default:'0-15' }}"
                      data-slices="{{ heatmap_time_slices|join:',' }}"
                      data-can-trigger="{% if can_trigger_analytics %}1{% else %}0{% endif %}">
                     <div class="heatmaps-header">
                         <div>
-                            <h3>Heatmaps</h3>
+                            <h3>Тепловые карты</h3>
                             <div class="heatmaps-controls">
                                 <label class="heatmaps-label" for="hm-map">Карта</label>
                                 <select id="hm-map" class="heatmaps-select">
                                     {% for map_name in available_maps %}
                                         <option value="{{ map_name }}"
                                                 {% if map_name == analytics_map %}selected{% endif %}>
                                             {{ map_name }}
                                         </option>
                                     {% endfor %}
                                 </select>
                                 <label class="heatmaps-label" for="hm-slice">Время раунда</label>
                                 <div class="heatmaps-slider">
                                     <input id="hm-slice" type="range" min="0" max="{{ heatmap_time_slices|length|add:'-1' }}"
                                            step="1" value="0" />
                                     <span id="hm-slice-label" class="heatmaps-meta heatmaps-meta--inline"></span>
                                 </div>
-                                <label class="heatmaps-label" for="hm-resolution">Grid</label>
+                                <label class="heatmaps-label" for="hm-resolution">Сетка</label>
                                 <select id="hm-resolution" class="heatmaps-select">
                                     <option value="64">64</option>
                                     <option value="128">128</option>
                                     <option value="256">256</option>
                                 </select>
                             </div>
                             <div class="heatmaps-tabs" data-group="metric">
                                 <button type="button" class="hm-tab active" data-group="metric" data-value="kills">
-                                    Kills
+                                    Убийства
                                 </button>
                                 <button type="button" class="hm-tab" data-group="metric" data-value="deaths">
-                                    Deaths
+                                    Смерти
                                 </button>
                                 <button type="button" class="hm-tab" data-group="metric" data-value="presence">
-                                    Presence
+                                    Присутствие
                                 </button>
                             </div>
+                            <div class="heatmaps-label heatmaps-label--inline">Сторона</div>
                             <div class="heatmaps-tabs heatmaps-tabs--secondary" data-group="side">
-                                <button type="button" class="hm-tab active" data-group="side" data-value="ALL">All</button>
-                                <button type="button" class="hm-tab" data-group="side" data-value="CT">CT</button>
-                                <button type="button" class="hm-tab" data-group="side" data-value="T">T</button>
+                                <button type="button" class="hm-tab active" data-group="side" data-value="all">Все</button>
+                                <button type="button" class="hm-tab" data-group="side" data-value="ct">CT</button>
+                                <button type="button" class="hm-tab" data-group="side" data-value="t">T</button>
                             </div>
                         </div>
                     </div>
 
                     <div id="hm-status" class="heatmaps-meta">Загрузка тепловой карты…</div>
                     <div id="hm-spinner" class="heatmaps-spinner" aria-hidden="true"></div>
                     <div class="heatmaps-body">
-                        <img id="hm-img" class="heatmap-img" alt="heatmap" loading="lazy" />
+                        <img id="hm-img" class="heatmap-img" alt="тепловая карта" loading="lazy" />
                         <div class="heatmaps-actions">
                             <button id="hm-regenerate" type="button" class="heatmaps-btn">
                                 Обновить картинки
                             </button>
                             <span id="hm-regenerate-status" class="heatmaps-meta heatmaps-meta--inline" aria-live="polite"></span>
                         </div>
                     </div>
                 </div>
 
                 <!-- Информация о последнем обновлении -->
                 {% if player_profile.last_faceit_update %}
                 <div class="update-info">
                     <p>
                         <small>
                             Данные обновлены: {{ player_profile.last_faceit_update|date:"d.m.Y H:i" }}
                             {% if days_since_update %}
                                 ({{ days_since_update }} дней назад)
                             {% endif %}
                         </small>
                     </p>
                 </div>
                 {% endif %}
 
             </div>
             {% else %}
@@ -1226,50 +1246,54 @@
         flex-wrap: wrap;
     }
 
     .heatmaps-controls {
         display: flex;
         align-items: center;
         gap: 0.5rem;
         margin-top: 0.5rem;
     }
 
     .heatmaps-slider {
         display: flex;
         align-items: center;
         gap: 0.4rem;
     }
 
     #hm-slice {
         width: 140px;
     }
 
     .heatmaps-label {
         font-size: 0.85rem;
         color: #6c757d;
     }
 
+    .heatmaps-label--inline {
+        margin-top: 0.35rem;
+    }
+
     .heatmaps-select {
         padding: 0.4rem 0.6rem;
         border-radius: 8px;
         border: 1px solid rgba(0, 0, 0, 0.12);
         background: #fff;
     }
 
     .heatmaps-tabs--secondary {
         margin-top: 0.65rem;
     }
 
     .hm-tab {
         padding: 0.5rem 0.9rem;
         border-radius: 10px;
         border: 1px solid rgba(0, 0, 0, 0.12);
         background: transparent;
         color: #343a40;
         cursor: pointer;
         transition: all 0.2s ease;
     }
 
     .hm-tab.active,
     .hm-tab:hover {
         background: rgba(67, 97, 238, 0.12);
         border-color: rgba(67, 97, 238, 0.35);
@@ -1599,71 +1623,71 @@
         const mapSelect = document.getElementById("hm-map");
         const resolutionSelect = document.getElementById("hm-resolution");
         const sliceInput = document.getElementById("hm-slice");
         const sliceLabel = document.getElementById("hm-slice-label");
         const spinner = document.getElementById("hm-spinner");
         const regenerateBtn = document.getElementById("hm-regenerate");
         const regenerateStatus = document.getElementById("hm-regenerate-status");
         const heatmapProfileId = (root?.dataset?.profileId || "").trim();
         const defaultMap = (root?.dataset?.map || "de_mirage").trim() || "de_mirage";
         const period = (root?.dataset?.period || "last_20").trim() || "last_20";
         const version = (root?.dataset?.version || "v2").trim() || "v2";
         const resolution = (root?.dataset?.resolution || "256").trim() || "256";
         const defaultMetric = (root?.dataset?.metric || "kills").trim().toLowerCase() || "kills";
         const sliceOptions = (root?.dataset?.slices || "0-15")
             .split(",")
             .map((v) => v.trim())
             .filter(Boolean);
         const defaultSlice = (root?.dataset?.slice || sliceOptions[0] || "0-15").trim();
         const canTrigger = (root?.dataset?.canTrigger || "0").trim() === "1";
 
         function setActive(tabs, value) {
             tabs.forEach((t) => t.classList.toggle("active", t.dataset.value === value));
         }
 
         if (!heatmapProfileId) {
-            status.textContent = "Heatmaps недоступны.";
+            status.textContent = "Тепловые карты недоступны.";
             return;
         }
 
         if (mapSelect) {
             mapSelect.value = defaultMap;
         }
         if (resolutionSelect) {
             resolutionSelect.value = resolution;
         }
         let currentSliceIndex = Math.max(sliceOptions.indexOf(defaultSlice), 0);
         let currentSlice = sliceOptions[currentSliceIndex] || defaultSlice;
         if (sliceInput && sliceOptions.length) {
             sliceInput.max = `${Math.max(sliceOptions.length - 1, 0)}`;
             sliceInput.value = `${currentSliceIndex}`;
         }
         if (sliceLabel) {
             sliceLabel.textContent = currentSlice;
         }
 
-        let currentSide = "ALL";
+        let currentSide = "all";
         let currentMap = defaultMap;
         let currentMetric = defaultMetric;
         let currentResolution = resolution;
         let pollingTimer = null;
         let pollAttempts = 0;
         const maxPollAttempts = 10;
         const regenerateLabel = regenerateBtn ? regenerateBtn.textContent.trim() : "";
 
         function setLoading(isLoading) {
             if (spinner) {
                 spinner.classList.toggle("is-active", isLoading);
                 spinner.setAttribute("aria-hidden", isLoading ? "false" : "true");
             }
         }
 
         function setRegenerating(isRegenerating) {
             if (!regenerateBtn || !regenerateStatus) {
                 return;
             }
             regenerateBtn.disabled = isRegenerating;
             regenerateStatus.textContent = isRegenerating ? "Обновляю…" : "";
             if (regenerateBtn) {
                 regenerateBtn.textContent = isRegenerating ? "Обновляю…" : regenerateLabel;
             }
         }
@@ -1680,103 +1704,103 @@
             }
             pollingTimer = null;
         }
 
         async function fetchHeatmap({ force = false } = {}) {
             clearPolling();
             pollAttempts = 0;
             status.textContent = "Загрузка тепловой карты…";
             setLoading(true);
             img.style.display = "none";
             let waitingForImage = false;
 
             const apiUrl = `/api/heatmaps/me` +
                 `?map=${encodeURIComponent(currentMap)}` +
                 `&metric=${encodeURIComponent(currentMetric)}` +
                 `&side=${encodeURIComponent(currentSide)}` +
                 `&period=${encodeURIComponent(period)}` +
                 `&slice=${encodeURIComponent(currentSlice)}` +
                 `&v=${encodeURIComponent(version)}` +
                 `&res=${encodeURIComponent(currentResolution)}` +
                 (force ? "&force=1" : "");
 
             try {
                 const r = await fetch(apiUrl, { headers: { Accept: "application/json" } });
                 if (!r.ok) {
-                    status.textContent = "Не удалось загрузить heatmap.";
+                    status.textContent = "Не удалось загрузить тепловую карту.";
                     if (force) {
                         alert("Не удалось обновить картинку.");
                     }
                     setLoading(false);
                     return;
                 }
                 const data = await r.json();
                 if (data.status === "ready" && data.image_url) {
                     img.style.display = "block";
                     const cacheBusted = force
                         ? `${data.image_url}${data.image_url.includes("?") ? "&" : "?"}cb=${Date.now()}`
                         : data.image_url;
                     waitingForImage = true;
                     img.onload = () => {
                         status.textContent = "";
                         setLoading(false);
                         setRegenerating(false);
                     };
                     img.onerror = () => {
                         status.textContent = "Не удалось загрузить изображение.";
                         setLoading(false);
                         setRegenerating(false);
                         if (force) {
                             alert("Не удалось обновить картинку.");
                         }
                     };
                     img.src = cacheBusted;
                     return;
                 }
                 if (data.status === "processing") {
-                    status.textContent = "Heatmap обрабатывается…";
+                    status.textContent = "Тепловая карта обрабатывается…";
                     setLoading(true);
                     pollAttempts += 1;
                     if (pollAttempts <= maxPollAttempts) {
                         pollingTimer = setTimeout(fetchHeatmap, 2500);
                     } else {
-                        status.textContent = "Heatmap ещё не готова. Попробуйте позже.";
+                        status.textContent = "Тепловая карта ещё не готова. Попробуйте позже.";
                         setLoading(false);
                     }
                     return;
                 }
                 setMissingMessage();
                 if (force) {
                     alert("Не удалось обновить картинку.");
                 }
             } catch (e) {
-                status.textContent = "Ошибка при загрузке heatmap.";
+                status.textContent = "Ошибка при загрузке тепловой карты.";
                 if (force) {
                     alert("Не удалось обновить картинку.");
                 }
             } finally {
-                if (!waitingForImage && status.textContent !== "Heatmap обрабатывается…") {
+                if (!waitingForImage && status.textContent !== "Тепловая карта обрабатывается…") {
                     setLoading(false);
                 }
                 if (!waitingForImage && status.textContent !== "") {
                     setRegenerating(false);
                 }
             }
         }
 
         sideTabs.forEach((t) =>
             t.addEventListener("click", () => {
                 currentSide = t.dataset.value;
                 setActive(sideTabs, currentSide);
                 fetchHeatmap();
             })
         );
 
         metricTabs.forEach((t) =>
             t.addEventListener("click", () => {
                 currentMetric = t.dataset.value;
                 setActive(metricTabs, currentMetric);
                 fetchHeatmap();
             })
         );
 
         if (mapSelect) {
diff --git a/users/tests/test_profile_dirs.py b/users/tests/test_profile_dirs.py
index 4e906e67dd030ee1448e3f8a041ebf54d19f1c31..22d0d9187351451b9e8c0c3a9b523a0117ad01b5 100644
--- a/users/tests/test_profile_dirs.py
+++ b/users/tests/test_profile_dirs.py
@@ -9,29 +9,29 @@ from faceit_analytics.services.heatmaps import DEFAULT_MAPS
 from faceit_analytics.services.paths import ensure_profile_dirs
 from users.models import PlayerProfile
 
 
 def test_profile_dirs_created_and_idempotent(tmp_path):
     media_root = tmp_path / "media"
     with override_settings(MEDIA_ROOT=media_root):
         unique_suffix = uuid4().hex
         unique_email = f"demo-user-{unique_suffix}@example.com"
         user = get_user_model().objects.create_user(
             username=f"demo-user-{unique_suffix}",
             email=unique_email,
             password="pass",
             user_type="player",
         )
         profile = PlayerProfile.objects.create(user=user, steam_id="76561198000000010")
 
         ensure_profile_dirs(profile)
         ensure_profile_dirs(profile)
 
         map_name = list(DEFAULT_MAPS)[0]
         expected_dirs = [
             media_root / "local_demos" / profile.steam_id / map_name,
             media_root / "heatmaps_cache" / profile.steam_id / map_name,
             media_root / "heatmaps_local" / profile.steam_id / "aggregate" / map_name,
-            media_root / "heatmaps" / str(profile.id) / map_name / "ALL" / "last_20",
+            media_root / "heatmaps" / str(profile.id) / map_name / "all" / "last_20",
         ]
         for path in expected_dirs:
             assert Path(path).exists()
diff --git a/users/views.py b/users/views.py
index c32f9146bdae7e1764f38cca609b1b2d3c3c24aa..8efc90c2e0f19951ab292311ecabd695adabc2c2 100644
--- a/users/views.py
+++ b/users/views.py
@@ -1,39 +1,39 @@
 from django.core.cache import cache
 from django.shortcuts import render, redirect, get_object_or_404
 from django.contrib.auth import login
 from django.contrib.auth.decorators import login_required
 from django.conf import settings
 from django.contrib import messages
 from django.db.models import Q
 from django.utils import timezone
 from django.views.decorators.http import require_POST
 
 from faceit_analytics.cache_keys import DEFAULT_TTL_SECONDS, profile_metrics_key
 from faceit_analytics.constants import ANALYTICS_VERSION
 from faceit_analytics.models import AnalyticsAggregate, HeatmapAggregate, ProcessingJob
-from faceit_analytics.services.heatmaps import DEFAULT_MAPS
+from faceit_analytics.services.heatmaps import DEFAULT_MAPS, get_time_slice_labels, normalize_map_name
 from faceit_analytics.tasks import task_full_pipeline
 from .forms import (
     RegistrationStep1Form,
     PlayerRegistrationForm,
     PlayerDetailsForm,
     TeamRegistrationForm,
     TeamDetailsForm
 )
 from .models import CustomUser, PlayerProfile, TeamProfile
 from .faceit import check_faceit_nickname, fetch_faceit_profile_details
 
 
 # ---------------------------
 # HOME
 # ---------------------------
 def home(request):
     """Главная страница"""
     context = {}
 
     if request.user.is_authenticated:
         if request.user.user_type == 'player':
             context['feed_title'] = 'Команды, которые ищут игроков'
             context['feed_items'] = (
                 TeamProfile.objects.select_related('user')
                 .filter(is_active=True)
@@ -225,86 +225,94 @@ def profile(request, user_id):
 
     # Проверяем права доступа
     if not request.user.is_superuser and request.user != user:
         messages.error(request, 'У вас нет доступа к этому профилю.')
         return redirect('home')
 
     context = {'profile_user': user, 'steamid64': ''}
 
     if user.user_type == CustomUser.USER_TYPE_PLAYER:
         try:
             player_profile = PlayerProfile.objects.get(user=user)
             context['player_profile'] = player_profile
             context['steamid64'] = (
                 getattr(player_profile, "steamid64", None)
                 or getattr(player_profile, "steam_id64", None)
                 or getattr(player_profile, "steam_id", None)
                 or ""
             )
             context['steamid64_debug'] = {
                 "steamid64": getattr(player_profile, "steamid64", None),
                 "steam_id64": getattr(player_profile, "steam_id64", None),
                 "steam_id": getattr(player_profile, "steam_id", None),
             }
 
             period = "last_20"
-            map_name = (request.GET.get("map") or "de_mirage").strip() or "de_mirage"
-            slice_labels = [
-                f"{int(start)}-{int(end)}" for start, end in getattr(settings, "HEATMAP_TIME_SLICES", [(0, 999)])
-            ]
+            map_name = normalize_map_name(request.GET.get("map") or "de_mirage")
+            slice_labels = get_time_slice_labels()
             cache_key = profile_metrics_key(player_profile.id, period, map_name, ANALYTICS_VERSION)
             try:
                 analytics_aggregates = cache.get(cache_key)
             except Exception:
                 analytics_aggregates = None
             if analytics_aggregates is None:
                 analytics_aggregates = list(
                     AnalyticsAggregate.objects.filter(
                         profile=player_profile,
                         period=period,
                         analytics_version=ANALYTICS_VERSION,
                         map_name=map_name,
                     )
                 )
                 try:
                     cache.set(cache_key, analytics_aggregates, DEFAULT_TTL_SECONDS)
                 except Exception:
                     pass
 
             context["analytics_period"] = period
             context["analytics_map"] = map_name
             context["available_maps"] = list(DEFAULT_MAPS)
             context["heatmap_time_slices"] = slice_labels
             context["heatmap_default_slice"] = getattr(settings, "HEATMAP_DEFAULT_SLICE", slice_labels[0])
             context["analytics_aggregates"] = analytics_aggregates
             context["analytics_ready"] = bool(analytics_aggregates)
             context["analytics_version"] = ANALYTICS_VERSION
             if analytics_aggregates:
                 metrics_json = analytics_aggregates[0].metrics_json or {}
                 context["analytics_metrics"] = metrics_json
+                label_map = {
+                    "win_rate": "Винрейт",
+                    "average_kd": "Средний KD",
+                    "average_hs": "Средний HS",
+                    "elo": "ELO",
+                    "matches": "Матчи",
+                    "wins": "Победы",
+                    "current_win_streak": "Текущая серия побед",
+                    "longest_win_streak": "Лучшая серия побед",
+                }
                 context["analytics_simple_metrics"] = {
-                    key: value
+                    label_map.get(key, key): value
                     for key, value in metrics_json.items()
                     if not isinstance(value, (dict, list))
                 }
             else:
                 context["analytics_metrics"] = {}
                 context["analytics_simple_metrics"] = {}
             context["heatmap_ready"] = HeatmapAggregate.objects.filter(
                 profile=player_profile,
                 period=period,
                 analytics_version=ANALYTICS_VERSION,
                 map_name=map_name,
             ).exists()
             analytics_job = (
                 ProcessingJob.objects.filter(
                     profile=player_profile,
                     job_type=ProcessingJob.JOB_FULL_PIPELINE,
                 )
                 .order_by("-created_at")
                 .first()
             )
             context["analytics_job"] = analytics_job
             context["analytics_job_active"] = bool(
                 analytics_job
                 and analytics_job.status
                 in (

